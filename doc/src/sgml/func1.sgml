<!-- 警告：このファイルは直接編集しないでください！
1. func.sgmlを編集したら、split.shを起動します。
2. するとfunc[0-4].sgmlが生成されます。
3. func.sgmlとともにfunc[0-4].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはfunc[0-4].sgmlに対して行います。
5. 指摘された点があればfunc.sgmlに反映し、1に戻ります。
6. func.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-func1-start -->

  <sect1 id="functions-logical">
<!--
   <title>Logical Operators</title>
-->
   <title>論理演算子</title>

   <indexterm zone="functions-logical">
<!--
    <primary>operator</primary>
    <secondary>logical</secondary>
-->
    <primary>演算子</primary>
    <secondary>論理</secondary>
   </indexterm>

   <indexterm>
<!--
    <primary>Boolean</primary>
    <secondary>operators</secondary>
    <see>operators, logical</see>
-->
    <primary>論理値</primary>
    <secondary>演算子</secondary>
    <see>演算子, 論理</see>
   </indexterm>

   <para>
<!--
    The usual logical operators are available:
-->
    通常の論理演算子が使用できます。

    <indexterm>
<!--
     <primary>AND (operator)</primary>
-->
     <primary>AND（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>OR (operator)</primary>
-->
     <primary>OR（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>NOT (operator)</primary>
-->
     <primary>NOT（演算子）</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>conjunction</primary>
-->
     <primary>論理積</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>disjunction</primary>
-->
     <primary>論理和</primary>
    </indexterm>

    <indexterm>
<!--
     <primary>negation</primary>
-->
     <primary>否定</primary>
    </indexterm>

    <simplelist>
     <member><literal>AND</literal></member>
     <member><literal>OR</literal></member>
     <member><literal>NOT</literal></member>
    </simplelist>

<!--
    <acronym>SQL</acronym> uses a three-valued logic system with true,
    false, and <literal>null</literal>, which represents <quote>unknown</quote>.
    Observe the following truth tables:
-->
<acronym>SQL</acronym>はtrue、false、そして<quote>不明</quote>を意味する<literal>null</literal>の3値の論理システムを使用します。
以下の真理値表を参照してください。

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
<!--
    The operators <literal>AND</literal> and <literal>OR</literal> are
    commutative, that is, you can switch the left and right operand
    without affecting the result.  But see <xref
    linkend="syntax-express-eval"/> for more information about the
    order of evaluation of subexpressions.
-->
<literal>AND</literal>演算子と<literal>OR</literal>演算子は可換です。
つまり、結果に影響を与えることなく左右のオペランドを交換することができます。
しかし、副式の評価順についてのより詳細は<xref linkend="syntax-express-eval"/>を参照してください。
   </para>
  </sect1>

  <sect1 id="functions-comparison">
<!--
   <title>Comparison Functions and Operators</title>
-->
   <title>比較関数および演算子</title>

   <indexterm zone="functions-comparison">
<!--
    <primary>comparison</primary>
    <secondary>operators</secondary>
-->
    <primary>比較</primary>
    <secondary>演算子</secondary>
   </indexterm>

   <para>
<!--
    The usual comparison operators are available, as shown in <xref
    linkend="functions-comparison-op-table"/>.
-->
<xref linkend="functions-comparison-op-table"/>に示すように、通常の比較演算子が使用可能です。
   </para>

   <table id="functions-comparison-op-table">
<!--
    <title>Comparison Operators</title>
-->
    <title>比較演算子</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
<!--
       <entry>less than</entry>
-->
       <entry>小なり</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
<!--
       <entry>greater than</entry>
-->
       <entry>大なり</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
<!--
       <entry>less than or equal to</entry>
-->
       <entry>等しいかそれ以下</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
<!--
       <entry>greater than or equal to</entry>
-->
       <entry>等しいかそれ以上</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
<!--
       <entry>equal</entry>
-->
       <entry>等しい</entry>
      </row>

      <row>
<!--
       <entry> <literal>&lt;&gt;</literal> or <literal>!=</literal> </entry>
-->
       <entry> <literal>&lt;&gt;</literal> または <literal>!=</literal> </entry>
<!--
       <entry>not equal</entry>
-->
       <entry>等しくない</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
<!--
     The <literal>!=</literal> operator is converted to
     <literal>&lt;&gt;</literal> in the parser stage.  It is not
     possible to implement <literal>!=</literal> and
     <literal>&lt;&gt;</literal> operators that do different things.
-->
<literal>!=</literal>演算子は構文解析で<literal>&lt;&gt;</literal>に変換されます。
<literal>!=</literal>演算子と<literal>&lt;&gt;</literal>演算子に異なる処理を行わせる実装はできません。
    </para>
   </note>

   <para>
<!--
    Comparison operators are available for all relevant data types.
    All comparison operators are binary operators that
    return values of type <type>boolean</type>; expressions like
    <literal>1 &lt; 2 &lt; 3</literal> are not valid (because there is
    no <literal>&lt;</literal> operator to compare a Boolean value with
    <literal>3</literal>).
-->
比較演算子は関連性のある全てのデータ型で使用できます。
全ての比較演算子は二項演算子で、<type>boolean</type>型の値を返します。<literal>1 &lt; 2 &lt; 3</literal>のような式は（ブール値と<literal>3</literal>を比較する<literal>&lt;</literal>演算子がないので）無効です。
   </para>

   <para>
<!--
    There are also some comparison predicates, as shown in <xref
    linkend="functions-comparison-pred-table"/>.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
-->
<xref linkend="functions-comparison-pred-table"/>に示すように、比較の述語がいくつかあります。
これらは演算子と同様に振る舞いますが、標準SQLによって強制される特別の構文があります。
   </para>

   <table id="functions-comparison-pred-table">
<!--
    <title>Comparison Predicates</title>
-->
    <title>比較述語</title>
    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Predicate</entry>
       <entry>Description</entry>
-->
       <entry>述語</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <replaceable>a</replaceable> <literal>BETWEEN</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>between</entry>
-->
       <entry>間にある</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>NOT BETWEEN</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>not between</entry>
-->
       <entry>間にない</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>BETWEEN SYMMETRIC</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>between, after sorting the comparison values</entry>
-->
       <entry>間にある（比較値をソートする）</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>NOT BETWEEN SYMMETRIC</literal> <replaceable>x</replaceable> <literal>AND</literal> <replaceable>y</replaceable> </entry>
<!--
       <entry>not between, after sorting the comparison values</entry>
-->
       <entry>間にない（比較値をソートする）</entry>
      </row>

      <row>
       <entry> <replaceable>a</replaceable> <literal>IS DISTINCT FROM</literal> <replaceable>b</replaceable> </entry>
<!--
       <entry>not equal, treating null like an ordinary value</entry>
-->
       <entry>等しくない（NULLは通常の値と同様に扱う）</entry>
      </row>

      <row>
       <entry><replaceable>a</replaceable> <literal>IS NOT DISTINCT FROM</literal> <replaceable>b</replaceable></entry>
<!--
       <entry>equal, treating null like an ordinary value</entry>
-->
       <entry>等しい（NULLは通常の値と同様に扱う）</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>IS NULL</literal> </entry>
<!--
       <entry>is null</entry>
-->
       <entry>NULLである</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>IS NOT NULL</literal> </entry>
<!--
       <entry>is not null</entry>
-->
       <entry>NULLでない</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>ISNULL</literal> </entry>
<!--
       <entry>is null (nonstandard syntax)</entry>
-->
       <entry>NULLである（非標準の構文）</entry>
      </row>

      <row>
       <entry> <replaceable>expression</replaceable> <literal>NOTNULL</literal> </entry>
<!--
       <entry>is not null (nonstandard syntax)</entry>
-->
       <entry>NULLでない（非標準の構文）</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS TRUE</literal> </entry>
<!--
       <entry>is true</entry>
-->
       <entry>真である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS NOT TRUE</literal> </entry>
<!--
       <entry>is false or unknown</entry>
-->
       <entry>偽あるいは不明である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS FALSE</literal> </entry>
<!--
       <entry>is false</entry>
-->
       <entry>偽である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS NOT FALSE</literal> </entry>
<!--
       <entry>is true or unknown</entry>
-->
       <entry>真あるいは不明である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS UNKNOWN</literal> </entry>
<!--
       <entry>is unknown</entry>
-->
       <entry>不明である</entry>
      </row>

      <row>
       <entry> <replaceable>boolean_expression</replaceable> <literal>IS NOT UNKNOWN</literal> </entry>
<!--
       <entry>is true or false</entry>
-->
       <entry>真あるいは偽である</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
<!--
    The <token>BETWEEN</token> predicate simplifies range tests:
-->
<token>BETWEEN</token>述語は範囲の検査を次のように単純にします。
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
と同じです。
<!--
    Notice that <token>BETWEEN</token> treats the endpoint values as included
    in the range.
    <literal>NOT BETWEEN</literal> does the opposite comparison:
-->
<token>BETWEEN</token>は範囲内に含まれるとして終点値を扱うことに注意してください。
<literal>NOT BETWEEN</literal>はその反対の比較をします（指定した値は包括しません）。
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
<!--
    is equivalent to
-->
は
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
と同一です。
    <indexterm>
     <primary>BETWEEN SYMMETRIC</primary>
    </indexterm>
<!--
    <literal>BETWEEN SYMMETRIC</literal> is like <literal>BETWEEN</literal>
    except there is no requirement that the argument to the left of
    <literal>AND</literal> be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
-->
<literal>BETWEEN SYMMETRIC</literal>は、<literal>AND</literal>の左側の引数が右側の引数より小さいか、もしくは等しいという必要性が無い点を除き<literal>BETWEEN</literal>と同様です。
この条件を満たしていない場合、2つの引数は自動的に交換されますので、常に空ではない範囲となります。
   </para>

   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT DISTINCT FROM</primary>
    </indexterm>
<!--
    Ordinary comparison operators yield null (signifying <quote>unknown</quote>),
    not true or false, when either input is null.  For example,
    <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;&gt; NULL</literal>.  When
    this behavior is not suitable, use the
    <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> predicates:
-->
入力のどちらかがNULLの場合、通常の比較演算子は真や偽ではなく（<quote>不明</quote>を意味する）nullを生成します。
例えば<literal>7 = NULL</literal>はnullになります。<literal>7 &lt;&gt; NULL</literal>も同様です。
この動作が適切でない場合は、<literal>IS <optional> NOT </optional> DISTINCT FROM</literal>述語を使用してください。
<synopsis>
<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>
<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</replaceable>
</synopsis>
<!--
    For non-null inputs, <literal>IS DISTINCT FROM</literal> is
    the same as the <literal>&lt;&gt;</literal> operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, <literal>IS NOT DISTINCT
    FROM</literal> is identical to <literal>=</literal> for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than <quote>unknown</quote>.
-->
非NULLの入力では、<literal>IS DISTINCT FROM</literal>は<literal>&lt;&gt;</literal>演算子と同じです。
しかし、入力がどちらもNULLの場合、これは偽を返し、片方の入力のみがNULLの場合は真を返します。
同様に、<literal>IS NOT DISTINCT FROM</literal>は非NULL入力では<literal>=</literal>と同じですが、両方の入力がNULLであれば真を、片方のみがNULLの場合は偽を返します。
このように、これらの述語はNULLを<quote>不明な値</quote>ではなく、通常の値かのように動作します。
   </para>

   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
<!--
    To check whether a value is or is not null, use the predicates:
-->
値がNULLかNULLでないかを検証するには次の述語を使います。
<synopsis>
<replaceable>expression</replaceable> IS NULL
<replaceable>expression</replaceable> IS NOT NULL
</synopsis>
<!--
    or the equivalent, but nonstandard, predicates:
-->
あるいは、これと同等の、非標準の述語も使えます。
<synopsis>
<replaceable>expression</replaceable> ISNULL
<replaceable>expression</replaceable> NOTNULL
</synopsis>
<!--
    <indexterm><primary>null value</primary><secondary>comparing</secondary></indexterm>
-->
    <indexterm><primary>NULL値</primary><secondary>比較</secondary></indexterm>
   </para>

   <para>
<!--
    Do <emphasis>not</emphasis> write
    <literal><replaceable>expression</replaceable> = NULL</literal>
    because <literal>NULL</literal> is not <quote>equal to</quote>
    <literal>NULL</literal>.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
-->
<literal>NULL</literal>と<literal>NULL</literal>とは<quote>等しい</quote>関係にはありませんので、<literal><replaceable>expression</replaceable> = NULL</literal>と記述しては<emphasis>いけません</emphasis>
（NULL値は不明の値を表しているため、不明な値同士が同じかどうかは識別できません）。
   </para>

  <tip>
   <para>
<!--
    Some applications might expect that
    <literal><replaceable>expression</replaceable> = NULL</literal>
    returns true if <replaceable>expression</replaceable> evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the <xref linkend="guc-transform-null-equals"/>
    configuration variable is available. If it is enabled,
    <productname>PostgreSQL</productname> will convert <literal>x =
    NULL</literal> clauses to <literal>x IS NULL</literal>.
-->
アプリケーションによっては、<literal><replaceable>expression</replaceable> = NULL</literal>が、<replaceable>expression</replaceable>がNULL値と評価されるのであれば真を返すことを期待することがあります。
こうしたアプリケーションは標準SQLに従うように改修することを強く推奨します。
しかし、それができなければ<xref linkend="guc-transform-null-equals"/>を使用することで対応することができます。
これを有効にした場合、<productname>PostgreSQL</productname>は<literal>x = NULL</literal>句を<literal>x IS NULL</literal>に変換します。
   </para>
  </tip>

   <para>
<!--
    If the <replaceable>expression</replaceable> is row-valued, then
    <literal>IS NULL</literal> is true when the row expression itself is null
    or when all the row's fields are null, while
    <literal>IS NOT NULL</literal> is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write <replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>
    or <replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
-->
<replaceable>expression</replaceable>が行値の場合、行式自体がNULLまたは、行のフィールドすべてがNULLの場合に<literal>IS NULL</literal>は真となります。
一方<literal>IS NOT NULL</literal>は、行式自体が非NULLかつ、行のフィールドすべてが非NULLの場合に真となります。
この動作により、<literal>IS NULL</literal>および<literal>IS NOT NULL</literal>は行値評価式に対し常に反対の結果を返すわけではありません。
特に、NULLと非NULLの値の両方を含む行値式はどちらの試験でも偽を返します。
場合によっては、<replaceable>row</replaceable> <literal>IS DISTINCT FROM NULL</literal>あるいは<replaceable>row</replaceable> <literal>IS NOT DISTINCT FROM NULL</literal>と記述する方が望ましいことがあるでしょう。
これらは単に行全体の値がNULLかどうかを検査し、行のフィールドについての追加的検査を全く行わないからです。
   </para>

   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
<!--
    Boolean values can also be tested using the predicates
-->
論理値も次の述語で検証できます。
<synopsis>
<replaceable>boolean_expression</replaceable> IS TRUE
<replaceable>boolean_expression</replaceable> IS NOT TRUE
<replaceable>boolean_expression</replaceable> IS FALSE
<replaceable>boolean_expression</replaceable> IS NOT FALSE
<replaceable>boolean_expression</replaceable> IS UNKNOWN
<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN
</synopsis>
<!--
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value <quote>unknown</quote>.
    Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</literal> are
    effectively the same as <literal>IS NULL</literal> and
    <literal>IS NOT NULL</literal>, respectively, except that the input
    expression must be of Boolean type.
-->
これらは、常に真か偽を返し、演算項目がNULLであってもNULL値を返すことはありません。
NULL値が入力されると、<quote>不明</quote>という論理値として扱われます。
<literal>IS UNKNOWN</literal>と<literal>IS NOT UNKNOWN</literal>が、入力式が論理値型でなければならないという点を除き、それぞれ実質的に<literal>IS NULL</literal>と<literal>IS NOT NULL</literal>と同じであることに注意してください。
   </para>

<!-- IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   <para>
    <indexterm>
     <primary>IS OF</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT OF</primary>
    </indexterm>
    It is possible to check the data type of an expression using the
    predicates
<synopsis>
<replaceable>expression</replaceable> IS OF (typename, ...)
<replaceable>expression</replaceable> IS NOT OF (typename, ...)
</synopsis>
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   </para>
-->

   <para>
<!--
    Some comparison-related functions are also available, as shown in <xref
    linkend="functions-comparison-func-table"/>.
-->
<xref linkend="functions-comparison-func-table"/>に示すように、比較に関連した関数がいくつか使用可能です。
   </para>

  <table id="functions-comparison-func-table">
<!--
    <title>Comparison Functions</title>
-->
    <title>比較関数</title>
    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Example Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>例の結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
         <indexterm>
          <primary>num_nonnulls</primary>
         </indexterm>
         <literal>num_nonnulls(VARIADIC "any")</literal>
       </entry>
<!--
       <entry>returns the number of non-null arguments</entry>
-->
       <entry>非NULLの引数の個数を返す</entry>
       <entry><literal>num_nonnulls(1, NULL, 2)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
      <row>
       <entry>
         <indexterm>
          <primary>num_nulls</primary>
         </indexterm>
         <literal>num_nulls(VARIADIC "any")</literal>
       </entry>
<!--
       <entry>returns the number of null arguments</entry>
-->
       <entry>NULLの引数の個数を返す</entry>
       <entry><literal>num_nulls(1, NULL, 2)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>

  <sect1 id="functions-math">
<!--
   <title>Mathematical Functions and Operators</title>
-->
   <title>算術関数と演算子</title>

   <para>
<!--
    Mathematical operators are provided for many
    <productname>PostgreSQL</productname> types. For types without
    standard mathematical conventions
    (e.g., date/time types) we
    describe the actual behavior in subsequent sections.
-->
<productname>PostgreSQL</productname>の数多くの型に対する算術演算子が用意されています。
標準算術表現法が存在しない型（例えば、日付/時刻データ型）については、後続する節で実際の動作を説明します。
   </para>

   <para>
<!--
    <xref linkend="functions-math-op-table"/> shows the available mathematical operators.
-->
<xref linkend="functions-math-op-table"/>は使用可能な算術演算子を示しています。
   </para>

   <table id="functions-math-op-table">
<!--
    <title>Mathematical Operators</title>
-->
    <title>算術演算子</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>演算子名</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
<!--
       <entry>addition</entry>
-->
       <entry>和</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
<!--
       <entry>subtraction</entry>
-->
       <entry>差</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
<!--
       <entry>multiplication</entry>
-->
       <entry>積</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
<!--
       <entry>division (integer division truncates the result)</entry>
-->
       <entry>商（整数の割り算では余りを切り捨て）</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
<!--
       <entry>modulo (remainder)</entry>
-->
       <entry>剰余（余り）</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
<!--
       <entry>exponentiation (associates left to right)</entry>
-->
       <entry>累乗(左から右に適用)</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
<!--
       <entry>square root</entry>
-->
       <entry>平方根</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
<!--
       <entry>cube root</entry>
-->
       <entry>立方根</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
<!--
       <entry>factorial</entry>
-->
       <entry>階乗</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
<!--
       <entry>factorial (prefix operator)</entry>
-->
       <entry>階乗（前置演算子）</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
<!--
       <entry>absolute value</entry>
-->
       <entry>絶対値</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
<!--
       <entry>bitwise AND</entry>
-->
       <entry>ビットごとのAND</entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
<!--
       <entry>bitwise OR</entry>
-->
       <entry>ビットごとのOR</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
<!--
       <entry>bitwise XOR</entry>
-->
       <entry>ビットごとのXOR</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
<!--
       <entry>bitwise NOT</entry>
-->
       <entry>ビットごとのNOT</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
<!--
       <entry>bitwise shift left</entry>
-->
       <entry>ビットごとの左シフト</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
<!--
       <entry>bitwise shift right</entry>
-->
       <entry>ビットごとの右シフト</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The bitwise operators work only on integral data types and are also
    available for the bit
    string types <type>bit</type> and <type>bit varying</type>, as
    shown in <xref linkend="functions-bit-string-op-table"/>.
-->
ビット演算子は整数データ型のみに使用できます。
また、ビット演算子は<xref linkend="functions-bit-string-op-table"/>に示すように、<type>bit</type>、<type>bit varying</type>ビット文字列型に対しても使用することができます。
   </para>

  <para>
<!--
   <xref linkend="functions-math-func-table"/> shows the available
   mathematical functions.  In the table, <literal>dp</literal>
   indicates <type>double precision</type>.  Many of these functions
   are provided in multiple forms with different argument types.
   Except where noted, any given form of a function returns the same
   data type as its argument.
   The functions working with <type>double precision</type> data are mostly
   implemented on top of the host system's C library; accuracy and behavior in
   boundary cases can therefore vary depending on the host system.
-->
<xref linkend="functions-math-func-table"/>に使用可能な算術関数を示します。
この表内の<literal>dp</literal>は、<type>double precision</type>を意味します。
これら関数の多くは、異なる引数型を持つ複数の形で提供されています。
特に記述がある場合を除き、すべての形式の関数はその引数と同じデータ型を返します。
<type>double precision</type>データに対する関数のほとんどはホストシステムのCライブラリの上層に実装されています。このため、精度と境界近くの場合の振舞いはホストシステムに依存して変わります。
  </para>

   <table id="functions-math-func-table">
<!--
    <title>Mathematical Functions</title>
-->
    <title>算術関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>abs</primary>
        </indexterm>
        <literal><function>abs(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力と同じ）</entry>
<!--
       <entry>absolute value</entry>
-->
       <entry>絶対値</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cbrt</primary>
        </indexterm>
        <literal><function>cbrt(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>cube root</entry>
-->
       <entry>立方根</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceil</primary>
        </indexterm>
        <literal><function>ceil(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
       <entry>nearest integer greater than or equal to argument</entry>
-->
       <entry>引数より大きいか等しく、引数に最も近い整数</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ceiling</primary>
        </indexterm>
        <literal><function>ceiling(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>nearest integer greater than or equal to argument (same as <function>ceil</function>)</entry>
-->
       <entry>引数より大きいか等しく、引数に最も近い整数（<function>ceil</function>と同じ）</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>degrees</primary>
        </indexterm>
        <literal><function>degrees(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>radians to degrees</entry>
-->
       <entry>ラジアンを度に変換</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565412</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>div</primary>
        </indexterm>
        <literal><function>div(<parameter>y</parameter> <type>numeric</type>,
         <parameter>x</parameter> <type>numeric</type>)</function></literal>
       </entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>integer quotient of <parameter>y</parameter>/<parameter>x</parameter></entry>
-->
       <entry><parameter>y</parameter>/<parameter>x</parameter>の整数商</entry>
       <entry><literal>div(9,4)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>exp</primary>
        </indexterm>
        <literal><function>exp(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>exponential</entry>
-->
       <entry>指数</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.71828182845905</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>floor</primary>
        </indexterm>
        <literal><function>floor(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>nearest integer less than or equal to argument</entry>
-->
       <entry>引数より小さいか等しく、引数に最も近い整数</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ln</primary>
        </indexterm>
        <literal><function>ln(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>natural logarithm</entry>
-->
       <entry>自然対数</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.693147180559945</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log</primary>
        </indexterm>
        <literal><function>log(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>base 10 logarithm</entry>
-->
       <entry>10を底とした対数（常用対数）</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>log10</primary>
        </indexterm>
<!--
        <literal><function>log10(<type>dp</type> or <type>numeric</type>)</function></literal>
-->
        <literal><function>log10(<type>dp</type>あるいは<type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
       <entry>base 10 logarithm</entry>
-->
       <entry>（入力型と同一）</entry>
       <entry>10を底とした対数（常用対数）</entry>
       <entry><literal>log10(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log(<parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>logarithm to base <parameter>b</parameter></entry>
-->
       <entry><parameter>b</parameter>を底とした対数</entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>mod</primary>
        </indexterm>
        <literal><function>mod(<parameter>y</parameter>,
         <parameter>x</parameter>)</function></literal>
       </entry>
<!--
       <entry>(same as argument types)</entry>
-->
       <entry>（引数の型と同一）</entry>
<!--
       <entry>remainder of <parameter>y</parameter>/<parameter>x</parameter></entry>
-->
       <entry><parameter>y</parameter>/<parameter>x</parameter>の剰余</entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pi</primary>
        </indexterm>
        <literal><function>pi()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry><quote>&pi;</quote> constant</entry>
-->
       <entry><quote>円周率（π）</quote>定数</entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>power</primary>
        </indexterm>
        <literal><function>power(<parameter>a</parameter> <type>dp</type>,
        <parameter>b</parameter> <type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry><parameter>a</parameter> raised to the power of <parameter>b</parameter></entry>
-->
       <entry><parameter>a</parameter>の<parameter>b</parameter>乗</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power(<parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry><parameter>a</parameter> raised to the power of <parameter>b</parameter></entry>
-->
       <entry><parameter>a</parameter>の<parameter>b</parameter>乗</entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>radians</primary>
        </indexterm>
        <literal><function>radians(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>degrees to radians</entry>
-->
       <entry>度をラジアンに変換</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.785398163397448</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>round</primary>
        </indexterm>
        <literal><function>round(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>round to nearest integer</entry>
-->
       <entry>最も近い整数への丸め</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>round to <parameter>s</parameter> decimal places</entry>
-->
       <entry>小数点第<parameter>s</parameter>位までの丸め</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>scale</primary>
        </indexterm>
        <literal><function>scale(<type>numeric</type>)</function></literal>
       </entry>
       <entry><type>integer</type></entry>
<!--
       <entry>scale of the argument (the number of decimal digits in the fractional part)</entry>
-->
       <entry>引数の位取り（小数点以下の十進の桁数）</entry>
       <entry><literal>scale(8.41)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sign</primary>
        </indexterm>
        <literal><function>sign(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>sign of the argument (-1, 0, +1)</entry>
-->
       <entry>引数の符号（-1、0、+1）</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sqrt</primary>
        </indexterm>
        <literal><function>sqrt(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>square root</entry>
-->
       <entry>平方根</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623731</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trunc</primary>
        </indexterm>
        <literal><function>trunc(<type>dp</type> or <type>numeric</type>)</function></literal>
       </entry>
<!--
       <entry>(same as input)</entry>
-->
       <entry>（入力型と同一）</entry>
<!--
       <entry>truncate toward zero</entry>
-->
       <entry>切り捨て</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>numeric</type></entry>
<!--
       <entry>truncate to <parameter>s</parameter> decimal places</entry>
-->
       <entry>小数点第<parameter>s</parameter>位までで切り捨て</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>width_bucket</primary>
        </indexterm>
        <literal><function>width_bucket(<parameter>operand</parameter> <type>dp</type>, <parameter>b1</parameter> <type>dp</type>, <parameter>b2</parameter> <type>dp</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket number to which <parameter>operand</parameter> would
       be assigned in a histogram having <parameter>count</parameter> equal-width
       buckets spanning the range <parameter>b1</parameter> to <parameter>b2</parameter>;
       returns <literal>0</literal> or <literal><parameter>count</parameter>+1</literal> for
       an input outside the range</entry>
-->
       <entry><parameter>b1</parameter>から<parameter>b2</parameter>までの範囲に広がる等幅でバケット数<parameter>count</parameter>のヒストグラムにおいて、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
範囲の外側の入力値に対しては<literal>0</literal>または<literal><parameter>count</parameter>+1</literal>を返す。</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>count</parameter> <type>int</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket number to which <parameter>operand</parameter> would
       be assigned in a histogram having <parameter>count</parameter> equal-width
       buckets spanning the range <parameter>b1</parameter> to <parameter>b2</parameter>;
       returns <literal>0</literal> or <literal><parameter>count</parameter>+1</literal> for
       an input outside the range</entry>
-->
       <entry><parameter>b1</parameter>から<parameter>b2</parameter>までの範囲に広がる等幅でバケット数<parameter>count</parameter>のヒストグラムにおいて、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
範囲の外側の入力値に対しては<literal>0</literal>または<literal><parameter>count</parameter>+1</literal>を返す。</entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket(<parameter>operand</parameter> <type>anyelement</type>, <parameter>thresholds</parameter> <type>anyarray</type>)</function></literal></entry>
       <entry><type>int</type></entry>
<!--
       <entry>return the bucket number to which <parameter>operand</parameter> would
       be assigned given an array listing the lower bounds of the buckets;
       returns <literal>0</literal> for an input less than the first lower bound;
       the <parameter>thresholds</parameter> array <emphasis>must be sorted</emphasis>,
       smallest first, or unexpected results will be obtained</entry>
-->
       <entry>バケットの下限値を列挙した配列に対し、<parameter>operand</parameter>が割り当てられるバケット番号を返す。
入力値が最初の下限値より小さいときは<literal>0</literal>を返す。
配列<parameter>thresholds</parameter>は最小のものを先頭に<emphasis>ソートされている必要があり</emphasis>、そうでなければ期待と異なる結果になる。</entry>
       <entry><literal>width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])</literal></entry>
       <entry><literal>2</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
    <xref linkend="functions-math-random-table"/> shows functions for
    generating random numbers.
-->
<xref linkend="functions-math-random-table"/>に乱数を生成する関数を示します。
  </para>

   <table id="functions-math-random-table">
<!--
    <title>Random Functions</title>
-->
    <title>乱数関数</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>random</primary>
        </indexterm>
        <literal><function>random()</function></literal>
       </entry>
       <entry><type>dp</type></entry>
<!--
       <entry>random value in the range 0.0 &lt;= x &lt; 1.0</entry>
-->
       <entry>0.0 &lt;= x &lt; 1.0の範囲の乱数値</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>setseed</primary>
        </indexterm>
        <literal><function>setseed(<type>dp</type>)</function></literal>
       </entry>
       <entry><type>void</type></entry>
<!--
       <entry>set seed for subsequent <literal>random()</literal> calls (value between -1.0 and
       1.0, inclusive)</entry>
-->
       <entry>今後の<literal>random()</literal>呼び出しで使用されるシード(種)の設定（-1.0から1.0までの境界を含む値）</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
<!--
   The <function>random()</function> function uses a simple linear
   congruential algorithm.  It is fast but not suitable for cryptographic
   applications; see the <xref linkend="pgcrypto"/> module for a more
   secure alternative.
   If <function>setseed()</function> is called, the results of
   subsequent <function>random()</function> calls in the current session are
   repeatable by re-issuing <function>setseed()</function> with the same
   argument.
-->
<function>random()</function>関数は単純な線形合同法を使用しています。
高速ですが、暗号用途には適していません。より安全な代替物として<xref linkend="pgcrypto"/>モジュールを参照してください。
<function>setseed()</function>が呼び出されると、現在のセッション内での以後の<function>random()</function>の呼び出し結果は<function>setseed()</function>を同じ引数で実行することによって再現可能となります。
  </para>

  <para>
<!--
   <xref linkend="functions-math-trig-table"/> shows the
   available trigonometric functions.  All these functions
   take arguments and return values of type <type>double
   precision</type>.  Each of the trigonometric functions comes in
   two variants, one that measures angles in radians and one that
   measures angles in degrees.
-->
使用可能な三角関数を<xref linkend="functions-math-trig-table"/>に示します。
全ての三角関数は<type>double precision</type>データ型の引数と戻り値を取ります。
それぞれの三角関数には、角度の単位をラジアンにするものと度にするものの2種類があります。
  </para>

   <table id="functions-math-trig-table">
<!--
    <title>Trigonometric Functions</title>
-->
    <title>三角関数</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Function (radians)</entry>
       <entry>Function (degrees)</entry>
       <entry>Description</entry>
-->
       <entry>関数（ラジアン）</entry>
       <entry>関数（度）</entry>
       <entry>説明</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>acos</primary>
        </indexterm><literal><function>acos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>acosd</primary>
        </indexterm><literal><function>acosd(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse cosine</entry>
-->
       <entry>逆余弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>asin</primary>
        </indexterm>
        <literal><function>asin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>asind</primary>
        </indexterm>
        <literal><function>asind(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse sine</entry>
-->
       <entry>逆正弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan</primary>
        </indexterm>
        <literal><function>atan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>atand</primary>
        </indexterm>
        <literal><function>atand(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse tangent</entry>
-->
       <entry>逆正接関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>atan2</primary>
        </indexterm>
        <literal><function>atan2(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>atan2d</primary>
        </indexterm>
        <literal><function>atan2d(<replaceable>y</replaceable>,
        <replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse tangent of
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal></entry>
-->
       <entry>
        <literal><replaceable>y</replaceable>/<replaceable>x</replaceable></literal>の逆正接関数
       </entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cos</primary>
        </indexterm>
        <literal><function>cos(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>cosd</primary>
        </indexterm>
        <literal><function>cosd(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>cosine</entry>
-->
       <entry>余弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>cot</primary>
        </indexterm>
        <literal><function>cot(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>cotd</primary>
        </indexterm>
        <literal><function>cotd(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>cotangent</entry>
-->
       <entry>余接関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sin</primary>
        </indexterm>
        <literal><function>sin(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>sind</primary>
        </indexterm>
        <literal><function>sind(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>sine</entry>
-->
       <entry>正弦関数</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>tan</primary>
        </indexterm>
        <literal><function>tan(<replaceable>x</replaceable>)</function></literal>
       </entry>
       <entry>
        <indexterm>
         <primary>tand</primary>
        </indexterm>
        <literal><function>tand(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>tangent</entry>
-->
       <entry>正接関数</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
<!--
    Another way to work with angles measured in degrees is to use the unit
    transformation functions <literal><function>radians()</function></literal>
    and <literal><function>degrees()</function></literal> shown earlier.
    However, using the degree-based trigonometric functions is preferred,
    as that way avoids round-off error for special cases such
    as <literal>sind(30)</literal>.
-->
度単位の角度を扱う別の方法は、前に示した単位変換関数<literal><function>radians()</function></literal>と<literal><function>degrees()</function></literal>を使うことです。
しかし、角度を使う方法の方が、<literal>sind(30)</literal>のような特別な場合の丸め誤差を避けられるため、推奨されます。
   </para>
  </note>

  <para>
<!--
   <xref linkend="functions-math-hyp-table"/> shows the
   available hyperbolic functions.  All these functions
   take arguments and return values of type <type>double
   precision</type>.
-->
利用可能な双曲線関数を<xref linkend="functions-math-hyp-table"/>に示します。
これら全ての関数は<type>double precision</type>データ型の引数と戻り値を取ります。
  </para>

  <table id="functions-math-hyp-table">
<!--
    <title>Hyperbolic Functions</title>
-->
    <title>双曲線関数</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>sinh</primary>
        </indexterm>
        <literal><function>sinh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>hyperbolic sine</entry>
-->
       <entry>双曲線正弦</entry>
       <entry><literal>sinh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>cosh</primary>
        </indexterm>
        <literal><function>cosh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>hyperbolic cosine</entry>
-->
       <entry>双曲線余弦</entry>
       <entry><literal>cosh(0)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>tanh</primary>
        </indexterm>
        <literal><function>tanh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>hyperbolic tangent</entry>
-->
       <entry>双曲線正接</entry>
       <entry><literal>tanh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>asinh</primary>
        </indexterm>
        <literal><function>asinh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse hyperbolic sine</entry>
-->
       <entry>逆双曲線正弦</entry>
       <entry><literal>asinh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>acosh</primary>
        </indexterm>
        <literal><function>acosh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse hyperbolic cosine</entry>
-->
       <entry>逆双曲線余弦</entry>
       <entry><literal>acosh(1)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
      <row>
       <entry>
        <indexterm>
         <primary>atanh</primary>
        </indexterm>
        <literal><function>atanh(<replaceable>x</replaceable>)</function></literal>
       </entry>
<!--
       <entry>inverse hyperbolic tangent</entry>
-->
       <entry>逆双曲線正接</entry>
       <entry><literal>atanh(0)</literal></entry>
       <entry><literal>0</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  </sect1>


  <sect1 id="functions-string">
<!--
   <title>String Functions and Operators</title>
-->
   <title>文字列関数と演算子</title>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating string values.  Strings in this context include values
    of the types <type>character</type>, <type>character varying</type>,
    and <type>text</type>.  Unless otherwise noted, all
    of the functions listed below work on all of these types, but be
    wary of potential effects of automatic space-padding when using the
    <type>character</type> type.  Some functions also exist
    natively for the bit-string types.
-->
本節では文字列の値の調査や操作のための関数と演算子について説明します。
ここでの文字列とは<type>character</type>データ型、<type>character varying</type>データ型、および<type>text</type>データ型の値を含みます。
補足説明のない限り、下記に挙げている全ての関数はこれら全てのデータ型に対して使用できますが、<type>character</type>データ型を使用した場合、自動的に空白文字が詰め込まれるという潜在的作用がありますので注意してください。
ビット文字列データ型に対する専用の関数もいくつかあります。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-string-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-string-other"/>).
-->
<acronym>SQL</acronym>では引数の区切りにカンマではなくキーワードを使用する文字列関数をいくつか定義しています。
詳細については<xref linkend="functions-string-sql"/>を参照してください。
また<productname>PostgreSQL</productname>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other"/>を参照してください）。
   </para>

   <note>
    <para>
<!--
     Before <productname>PostgreSQL</productname> 8.3, these functions would
     silently accept values of several non-string data types as well, due to
     the presence of implicit coercions from those data types to
     <type>text</type>.  Those coercions have been removed because they frequently
     caused surprising behaviors.  However, the string concatenation operator
     (<literal>||</literal>) still accepts non-string input, so long as at least one
     input is of a string type, as shown in <xref
     linkend="functions-string-sql"/>.  For other cases, insert an explicit
     coercion to <type>text</type> if you need to duplicate the previous behavior.
-->
<productname>PostgreSQL</productname>の8.3より前において、これらの関数はいくつかの非文字列データ型の値を警告なしに受け付けたのは、それらデータ型を暗黙的に<type>text</type>型に型変換していたことによります。
この強制的な変換は、頻繁に予期しない動作の原因となったので削除されました。
しかし、文字列連結演算子（<literal>||</literal>）は<xref linkend="functions-string-sql"/>で示されるように、少なくともひとつの入力が文字列型であれば、依然として非文字列入力を受け付けます。
その他の場合、以前と同じ動作が必要なら、<type>text</type>への明示的な変換を行ってください。
    </para>
   </note>

   <table id="functions-string-sql">
<!--
    <title><acronym>SQL</acronym> String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>文字列関数と演算子</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>
<!--
        String concatenation
-->
        文字列結合
        <indexterm>
<!--
         <primary>character string</primary>
         <secondary>concatenation</secondary>
-->
         <primary>文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
       </entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry>
<!--
        <literal><parameter>string</parameter> <literal>||</literal>
        <parameter>non-string</parameter></literal>
        or
        <literal><parameter>non-string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal>
-->
        <literal><parameter>文字列</parameter> <literal>||</literal>
        <parameter>非文字列</parameter></literal>
        または、
        <literal><parameter>非文字列</parameter> <literal>||</literal>
        <parameter>文字列</parameter></literal>
       </entry>
       <entry> <type>text</type> </entry>
       <entry>
<!--
        String concatenation with one non-string input
-->
        ひとつの非文字列の入力がある文字列結合
       </entry>
       <entry><literal>'Value: ' || 42</literal></entry>
       <entry><literal>Value: 42</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>bit_length</primary>
        </indexterm>
        <literal><function>bit_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bits in string</entry>
-->
       <entry>文字列中のビット数</entry>
       <entry><literal>bit_length('jose')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>char_length</primary>
        </indexterm>
<!--
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> or <literal><function>character_length(<parameter>string</parameter>)</function></literal>
-->
        <literal><function>char_length(<parameter>string</parameter>)</function></literal> または <literal><function>character_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in string
-->
        文字列中の文字数
        <indexterm>
<!--
         <primary>character string</primary>
         <secondary>length</secondary>
-->
         <primary>文字列</primary>
         <secondary>長さ</secondary>
        </indexterm>
        <indexterm>
<!--
         <primary>length</primary>
         <secondary sortas="character string">of a character string</secondary>
         <see>character string, length</see>
-->
         <primary>長さ</primary>
         <secondary sortas="character string">文字列の</secondary>
         <see>文字列, 長さ</see>
        </indexterm>
       </entry>
       <entry><literal>char_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <literal><function>lower(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert string to lower case</entry>
-->
       <entry>文字列を小文字に変換</entry>
       <entry><literal>lower('TOM')</literal></entry>
       <entry><literal>tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes in string</entry>
-->
       <entry>文字列中のバイト数</entry>
       <entry><literal>octet_length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Replace substring
-->
        部分文字列の置換
       </entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Location of specified substring</entry>
-->
       <entry>指定した部分文字列の場所</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring
-->
        部分文字列の取り出し
       </entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring matching POSIX regular expression. See
        <xref linkend="functions-matching"/> for more information on pattern
        matching.
-->
POSIX正規表現に一致する部分文字列を取り出します。
パターンマッチに関してより詳細は、<xref linkend="functions-matching"/>を参照してください。
       </entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable> for <replaceable>escape</replaceable>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring matching <acronym>SQL</acronym> regular expression.
        See <xref linkend="functions-matching"/> for more information on
        pattern matching.
-->
<acronym>SQL</acronym>正規表現に一致する部分文字列を取り出します。
パターンマッチに関してより詳細は、<xref linkend="functions-matching"/>を参照してください。
       </entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>leading | trailing | both</optional>
        <optional><parameter>characters</parameter></optional> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the
        start, end, or both ends (<literal>both</literal> is the default)
        of <parameter>string</parameter>
-->
<parameter>characters</parameter>（デフォルトでは空白）に含まれる文字のみを含む最も長い文字列を、<parameter>string</parameter>の先頭（start）、末尾（end）、あるいはその両方（both、デフォルトは<literal>both</literal>です）から削除します。
       </entry>
       <entry><literal>trim(both 'xyz' from 'yxTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim(<optional>leading | trailing
        | both</optional> <optional>from</optional>
        <parameter>string</parameter>
        <optional>, <parameter>characters</parameter></optional>
        )</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Non-standard syntax for <function>trim()</function>
-->
        <function>trim()</function>の標準と異なる構文
       </entry>
       <entry><literal>trim(both from 'yxTomxx', 'xyz')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <literal><function>upper(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert string to upper case</entry>
-->
       <entry>文字列を大文字に変換</entry>
       <entry><literal>upper('tom')</literal></entry>
       <entry><literal>TOM</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional string manipulation functions are available and are
    listed in <xref linkend="functions-string-other"/>.  Some of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref linkend="functions-string-sql"/>.
-->
この他、<xref linkend="functions-string-other"/>に列挙する文字列操作関数が使えます。
そのいくつかは、<xref linkend="functions-string-sql"/>で列挙した標準<acronym>SQL</acronym>の文字列関数を実装するため、内部的に使用されます。
   </para>

   <table id="functions-string-other">
<!--
    <title>Other String Functions</title>
-->
    <title>その他の文字列関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>ascii</primary>
        </indexterm>
        <literal><function>ascii(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        <acronym>ASCII</acronym> code of the first character of the
        argument.  For <acronym>UTF8</acronym> returns the Unicode code
        point of the character.  For other multibyte encodings, the
        argument must be an <acronym>ASCII</acronym> character.
-->
引数の最初の文字の<acronym>ASCII</acronym>コード。
<acronym>UTF8</acronym>に対しては文字のUnicodeコードポイントを返します。
その他のマルチバイト符号化方式の場合、引数は<acronym>ASCII</acronym>文字でなくてはなりません。
       </entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string consisting only of characters
        in <parameter>characters</parameter> (a space by default)
        from the start and end of <parameter>string</parameter>
-->
<parameter>characters</parameter>（デフォルトは空白文字）で指定された文字のみを有する最長の文字列を、<parameter>string</parameter>の先頭と末尾から削除します。
       </entry>
       <entry><literal>btrim('xyxtrimyyx', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>chr</primary>
        </indexterm>
        <literal><function>chr(<type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Character with the given code. For <acronym>UTF8</acronym> the
        argument is treated as a Unicode code point. For other multibyte
        encodings the argument must designate an
        <acronym>ASCII</acronym> character.  The NULL (0) character is not
        allowed because text data types cannot store such bytes.
-->
与えられたコードの文字。<acronym>UTF8</acronym>では引数はUnicodeコードポイントとして扱われます。
その他のマルチバイト符号化方式で引数は<acronym>ASCII</acronym>文字を指定するものである必要があります。
NULL (0)文字はテキストデータ型がそのようなバイトを格納することができないので許可されません。
       </entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat</primary>
        </indexterm>
        <literal><function>concat(<parameter>str</parameter> <type>"any"</type>
         [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Concatenate the text representations of all the arguments.
        NULL arguments are ignored.
-->
すべての引数のテキスト表現を結合します。NULLの引数は無視されます。
       </entry>
       <entry><literal>concat('abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde222</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>concat_ws</primary>
        </indexterm>
        <literal><function>concat_ws(<parameter>sep</parameter> <type>text</type>,
        <parameter>str</parameter> <type>"any"</type>
        [, <parameter>str</parameter> <type>"any"</type> [, ...] ])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Concatenate all but the first argument with separators. The first
        argument is used as the separator string. NULL arguments are ignored.
-->
第一引数を除くすべての引数を、区切り文字を付けて結合します。
第一引数は区切り文字列として使用されます。
NULLの引数は無視されます。
       </entry>
       <entry><literal>concat_ws(',', 'abcde', 2, NULL, 22)</literal></entry>
       <entry><literal>abcde,2,22</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert</primary>
        </indexterm>
        <literal><function>convert(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Convert string to <parameter>dest_encoding</parameter>.  The
        original encoding is specified by
        <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
        Conversions can be defined by <command>CREATE CONVERSION</command>.
        Also there are some predefined conversions. See <xref
        linkend="conversion-names"/> for available conversions.
-->
文字列を<parameter>dest_encoding</parameter>に変換します。
元の符号化方式は<parameter>src_encoding</parameter>で指定されます。
<parameter>string</parameter>はこの符号化方式で有効でなければなりません。
変換は<command>CREATE CONVERSION</command>で定義されます。
また、あらかじめ定義された変換もあります。
利用可能な変換については<xref linkend="conversion-names"/>を参照してください。
       </entry>
       <entry><literal>convert('text_in_utf8', 'UTF8', 'LATIN1')</literal></entry>
<!--
       <entry><literal>text_in_utf8</literal> represented in Latin-1
       encoding (ISO 8859-1)</entry>
-->
       <entry>Latin-1（ISO 8859-1）符号化方式の<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_from</primary>
        </indexterm>
        <literal><function>convert_from(<parameter>string</parameter> <type>bytea</type>,
        <parameter>src_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Convert string to the database encoding.  The original encoding
        is specified by <parameter>src_encoding</parameter>. The
        <parameter>string</parameter> must be valid in this encoding.
-->
データベースの符号化方式に文字列を変換します。
元の符号化方式は<parameter>src_encoding</parameter>で指定されます。
<parameter>string</parameter>はこの符号化方式で有効なものでなければなりません。
       </entry>
       <entry><literal>convert_from('text_in_utf8', 'UTF8')</literal></entry>
<!--
       <entry><literal>text_in_utf8</literal> represented in the current database encoding</entry>
-->
       <entry>現在のデータベース符号化方式の<literal>text_in_utf8</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>convert_to</primary>
        </indexterm>
        <literal><function>convert_to(<parameter>string</parameter> <type>text</type>,
        <parameter>dest_encoding</parameter> <type>name</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Convert string to <parameter>dest_encoding</parameter>.
-->
        文字列を<parameter>dest_encoding</parameter>に変換します。
       </entry>
       <entry><literal>convert_to('some text', 'UTF8')</literal></entry>
<!--
       <entry><literal>some text</literal> represented in the UTF8 encoding</entry>
-->
       <entry>UTF8符号化方式の<literal>some text</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
        <literal><function>decode(<parameter>string</parameter> <type>text</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Decode binary data from textual representation in <parameter>string</parameter>.
        Options for <parameter>format</parameter> are same as in <function>encode</function>.
-->
<parameter>string</parameter>のテキスト表現からバイナリデータを復号します。
<parameter>format</parameter>のオプションは<function>encode()</function>と同じです。
       </entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>\x3132330001</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
        <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
        <parameter>format</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Encode binary data into a textual representation.  Supported
        formats are: <literal>base64</literal>, <literal>hex</literal>, <literal>escape</literal>.
        <literal>escape</literal> converts zero bytes and high-bit-set bytes to
        octal sequences (<literal>\</literal><replaceable>nnn</replaceable>) and
        doubles backslashes.
-->
バイナリデータをテキスト表現形式に符号化します。
サポートされているformatは、<literal>base64</literal>、<literal>hex</literal>、<literal>escape</literal>です。
<literal>escape</literal>は0のバイトと最上位ビットがセットされているバイトを8進数のシーケンス(<literal>\</literal><replaceable>nnn</replaceable>)に変換し 、バックスラッシュを二重化します。
       </entry>
       <entry><literal>encode('123\000\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry id="format">
        <indexterm>
         <primary>format</primary>
        </indexterm>
        <literal><function>format</function>(<parameter>formatstr</parameter> <type>text</type>
        [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
         Format arguments according to a format string.
         This function is similar to the C function <function>sprintf</function>.
         See <xref linkend="functions-string-format"/>.
-->
引数の書式をフォーマット文字列に従って整えます。
この関数はC言語関数の<function>sprintf</function>と似ています。
<xref linkend="functions-string-format"/>を参照してください。
       </entry>
       <entry><literal>format('Hello %s, %1$s', 'World')</literal></entry>
       <entry><literal>Hello World, World</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>initcap</primary>
        </indexterm>
        <literal><function>initcap(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Convert the first letter of each word to upper case and the
        rest to lower case. Words are sequences of alphanumeric
        characters separated by non-alphanumeric characters.
-->
それぞれの単語の第一文字を大文字に、残りは小文字に変換します。
ここで単語とは、英数字以外の文字で区切られた、英数字からなる文字の並びのことです。
       </entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>left</primary>
        </indexterm>
        <literal><function>left(<parameter>str</parameter> <type>text</type>,
        <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return first <replaceable>n</replaceable> characters in the string. When <replaceable>n</replaceable>
        is negative, return all but last |<replaceable>n</replaceable>| characters.
-->
文字列の先頭から<replaceable>n</replaceable>文字を返します。
<replaceable>n</replaceable>が負数の場合、文字列の末尾から|<replaceable>n</replaceable>|文字を切り取った文字列を返します。
        </entry>
       <entry><literal>left('abcde', 2)</literal></entry>
       <entry><literal>ab</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>length</primary>
        </indexterm>
        <literal><function>length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in <parameter>string</parameter>
-->
        <parameter>string</parameter>内の文字数
       </entry>
       <entry><literal>length('jose')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>length(<parameter>string</parameter> <type>bytea</type>,
        <parameter>encoding</parameter> <type>name</type> )</function></literal></entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Number of characters in <parameter>string</parameter> in the given
        <parameter>encoding</parameter>. The <parameter>string</parameter>
        must be valid in this encoding.
-->
与えられた<parameter>encoding</parameter>での<parameter>string</parameter>内の文字数。
<parameter>string</parameter>はこの符号化方式で有効でなければなりません。
       </entry>
       <entry><literal>length('jose', 'UTF8')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>lpad</primary>
        </indexterm>
        <literal><function>lpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by prepending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated (on the
        right).
-->
文字<parameter>fill</parameter>（デフォルトは空白文字）を文字列の前に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は（右側が）切り捨てられます。
       </entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>ltrim</primary>
        </indexterm>
        <literal><function>ltrim(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the start of
        <parameter>string</parameter>
-->
<parameter>string</parameter>の最初から、<parameter>characters</parameter>（デフォルトはスペース）で指定された文字だけを有する最長の文字列を削除します。
       </entry>
       <entry><literal>ltrim('zzzytest', 'xyz')</literal></entry>
       <entry><literal>test</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>md5</primary>
        </indexterm>
        <literal><function>md5(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Calculates the MD5 hash of <parameter>string</parameter>,
        returning the result in hexadecimal
-->
<parameter>string</parameter>のMD5ハッシュを計算し、16進数で結果を返します。
       </entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>900150983cd24fb0 d6963f7d28e17f72</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>parse_ident</primary>
        </indexterm>
        <literal><function>parse_ident(<parameter>qualified_identifier</parameter> <type>text</type>
           [, <parameter>strictmode</parameter> <type>boolean</type> DEFAULT true ] )</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Split <parameter>qualified_identifier</parameter> into an array of
        identifiers, removing any quoting of individual identifiers.  By
        default, extra characters after the last identifier are considered an
        error; but if the second parameter is <literal>false</literal>, then such
        extra characters are ignored. (This behavior is useful for parsing
        names for objects like functions.) Note that this function does not
        truncate over-length identifiers. If you want truncation you can cast
        the result to <type>name[]</type>.
-->
<parameter>qualified_identifier</parameter>を識別子の配列に分割し、個々の識別子に引用符があればそれを削除します。
デフォルトでは、最後の識別子の後に続く余分な文字はエラーとされますが、2番目のパラメータが<literal>false</literal>の場合は、そのような余分な文字は無視されます。
（この動作は、関数のようなオブジェクトに対して名前を解析するときに便利でしょう。）
この関数は、長すぎる識別子を切り詰めないことに注意してください。
切り詰めが必要なときは、その結果を<type>name[]</type>にキャストすることができます。
       </entry>
       <entry><literal>parse_ident('"SomeSchema".someTable')</literal></entry>
       <entry><literal>{SomeSchema,sometable}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>pg_client_encoding</primary>
        </indexterm>
        <literal><function>pg_client_encoding()</function></literal>
       </entry>
       <entry><type>name</type></entry>
       <entry>
<!--
        Current client encoding name
-->
        現在のクライアントの符号化方式の名前。
       </entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_ident</primary>
        </indexterm>
        <literal><function>quote_ident(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as an identifier
        in an <acronym>SQL</acronym> statement string.
        Quotes are added only if necessary (i.e., if the string contains
        non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で識別子として使用できるように、適切な引用符を付けて返します。
引用符は、必要な場合（すなわち、文字列に識別子として使用できない文字が含まれる場合や、大文字変換される場合）にのみ追加されます。埋め込まれた引用符は、適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_literal</primary>
        </indexterm>
        <literal><function>quote_literal(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string.
        Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns null on null
        input; if the argument might be null,
        <function>quote_nullable</function> is often more suitable.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字リテラルとして使用できるように、適切な引用符を付けて返します。
埋め込まれた単一引用符およびバックスラッシュは、適切に二重化されます。
<function>quote_literal</function>はNULL入力に対してNULLを返すことに注意してください。引数がNULLとなる可能性がある場合、より<function>quote_nullable</function>の方がしばしば適しています。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </entry>
       <entry><literal>quote_literal(E'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Coerce the given value to text and then quote it as a literal.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに変換し、そしてリテラルとして引用符付けします。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </entry>
       <entry><literal>quote_literal(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>quote_nullable</primary>
        </indexterm>
        <literal><function>quote_nullable(<parameter>string</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return the given string suitably quoted to be used as a string literal
        in an <acronym>SQL</acronym> statement string; or, if the argument
        is null, return <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
        See also <xref linkend="plpgsql-quote-literal-example"/>.
-->
与えられた文字列を、<acronym>SQL</acronym>問い合わせ文字列で文字列リテラルとして使用できるように、適切な引用符を付けて返します。
また、引数がNULLの場合、<literal>NULL</literal>を返します。
埋め込まれた単一引用符およびバックスラッシュは適切に二重化されます。
<xref linkend="plpgsql-quote-literal-example"/>も参照してください。
       </entry>
       <entry><literal>quote_nullable(NULL)</literal></entry>
       <entry><literal>NULL</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_nullable(<parameter>value</parameter> <type>anyelement</type>)</function></literal></entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Coerce the given value to text and then quote it as a literal;
        or, if the argument is null, return <literal>NULL</literal>.
        Embedded single-quotes and backslashes are properly doubled.
-->
与えられた値をテキストに変換し、そしてリテラルとして引用符付けします。引数がNULLの場合は<literal>NULL</literal>を返します。
埋め込まれた単一引用符とバックスラッシュは適切に二重化されます。
       </entry>
       <entry><literal>quote_nullable(42.5)</literal></entry>
       <entry><literal>'42.5'</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_match</primary>
        </indexterm>
        <literal><function>regexp_match(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Return captured substring(s) resulting from the first match of a POSIX
        regular expression to the <parameter>string</parameter>. See
        <xref linkend="functions-posix-regexp"/> for more information.
-->
<parameter>string</parameter>に対してPOSIX正規表現でマッチし、捕捉された最初の部分文字列を返します。
より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </entry>
       <entry><literal>regexp_match('foobarbequebaz', '(bar)(beque)')</literal></entry>
       <entry><literal>{bar,beque}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_matches</primary>
        </indexterm>
        <literal><function>regexp_matches(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text[]</type></entry>
       <entry>
<!--
        Return captured substring(s) resulting from matching a POSIX regular
        expression to the <parameter>string</parameter>. See
        <xref linkend="functions-posix-regexp"/> for more information.
-->
<parameter>string</parameter>に対してPOSIX正規表現でマッチし、捕捉された部分文字列を返します。
より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </entry>
       <entry><literal>regexp_matches('foobarbequebaz', 'ba.', 'g')</literal></entry>
       <entry><literal>{bar}</literal><para><literal>{baz}</literal></para> (2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_replace</primary>
        </indexterm>
        <literal><function>regexp_replace(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type>, <parameter>replacement</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Replace substring(s) matching a POSIX regular expression. See
        <xref linkend="functions-posix-regexp"/> for more information.
-->
POSIX正規表現に一致する部分文字列を置換します。
より詳細は<xref linkend="functions-posix-regexp"/>を参照してください。
       </entry>
       <entry><literal>regexp_replace('Thomas', '.[mN]a.', 'M')</literal></entry>
       <entry><literal>ThM</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_array</primary>
        </indexterm>
        <literal><function>regexp_split_to_array(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type> ])</function></literal>
       </entry>
       <entry><type>text[]</type></entry>
       <entry>
<!--
        Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"/> for more
        information.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp"/>を参照ください。
       </entry>
       <entry><literal>regexp_split_to_array('hello world', '\s+')</literal></entry>
       <entry><literal>{hello,world}</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>regexp_split_to_table</primary>
        </indexterm>
        <literal><function>regexp_split_to_table(<parameter>string</parameter> <type>text</type>, <parameter>pattern</parameter> <type>text</type> [, <parameter>flags</parameter> <type>text</type>])</function></literal>
       </entry>
       <entry><type>setof text</type></entry>
       <entry>
<!--
        Split <parameter>string</parameter> using a POSIX regular expression as
        the delimiter.  See <xref linkend="functions-posix-regexp"/> for more
        information.
-->
POSIX正規表現を区切り文字に使って<parameter>string</parameter>を分割します。
詳しくは<xref linkend="functions-posix-regexp"/>を参照ください。
       </entry>
       <entry><literal>regexp_split_to_table('hello world', '\s+')</literal></entry>
       <entry><literal>hello</literal><para><literal>world</literal></para> (2 rows)</entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>repeat</primary>
        </indexterm>
        <literal><function>repeat(<parameter>string</parameter> <type>text</type>, <parameter>number</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Repeat <parameter>string</parameter> the specified
       <parameter>number</parameter> of times</entry>
-->
       <entry>指定された<parameter>number</parameter>の数だけ<parameter>string</parameter>を繰り返します。</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>replace</primary>
        </indexterm>
        <literal><function>replace(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Replace all occurrences in <parameter>string</parameter> of substring
        <parameter>from</parameter> with substring <parameter>to</parameter>
-->
       <entry><parameter>string</parameter>に出現する全ての<parameter>from</parameter>部分文字列を<parameter>to</parameter>部分文字列に置換します。
       </entry>
       <entry><literal>replace('abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>reverse</primary>
        </indexterm>
        <literal><function>reverse(<parameter>str</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return reversed string.
-->
        逆順にした文字列を返します。
       </entry>
       <entry><literal>reverse('abcde')</literal></entry>
       <entry><literal>edcba</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>right</primary>
        </indexterm>
        <literal><function>right(<parameter>str</parameter> <type>text</type>,
         <parameter>n</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Return last <replaceable>n</replaceable> characters in the string. When <replaceable>n</replaceable>
        is negative, return all but first |<replaceable>n</replaceable>| characters.
-->
文字列の末尾から<replaceable>n</replaceable>文字を返します。
<replaceable>n</replaceable>が負数の場合は、文字列の先頭から|<replaceable>n</replaceable>|文字だけ切り取った文字列を返します。
       </entry>
       <entry><literal>right('abcde', 2)</literal></entry>
       <entry><literal>de</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rpad</primary>
        </indexterm>
        <literal><function>rpad(<parameter>string</parameter> <type>text</type>,
        <parameter>length</parameter> <type>int</type>
        <optional>, <parameter>fill</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Fill up the <parameter>string</parameter> to length
        <parameter>length</parameter> by appending the characters
        <parameter>fill</parameter> (a space by default).  If the
        <parameter>string</parameter> is already longer than
        <parameter>length</parameter> then it is truncated.
-->
文字<parameter>fill</parameter>（デフォルトはスペース）を文字列に追加して、<parameter>string</parameter>を<parameter>length</parameter>の長さにします。
<parameter>string</parameter>が既に<parameter>length</parameter>の長さを超えている場合は切り捨てられます。
       </entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>rtrim</primary>
        </indexterm>
        <literal><function>rtrim(<parameter>string</parameter> <type>text</type>
         <optional>, <parameter>characters</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Remove the longest string containing only characters from
        <parameter>characters</parameter> (a space by default) from the end of
        <parameter>string</parameter>
-->
<parameter>string</parameter>の末尾から、<parameter>characters</parameter>（デフォルトはスペース）で指定された文字のみを有する最長の文字列を削除します。
       </entry>
       <entry><literal>rtrim('testxxzx', 'xyz')</literal></entry>
       <entry><literal>test</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>split_part</primary>
        </indexterm>
        <literal><function>split_part(<parameter>string</parameter> <type>text</type>,
        <parameter>delimiter</parameter> <type>text</type>,
        <parameter>field</parameter> <type>int</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Split <parameter>string</parameter> on <parameter>delimiter</parameter>
        and return the given field (counting from one)
-->
       <entry><parameter>string</parameter>を<parameter>delimiter</parameter>で分割し、その結果から（1から始まるように数える）指定したフィールドを返します。
       </entry>
       <entry><literal>split_part('abc~@~def~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>strpos</primary>
        </indexterm>
        <literal><function>strpos(<parameter>string</parameter>, <parameter>substring</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Location of specified substring (same as
        <literal>position(<parameter>substring</parameter> in
         <parameter>string</parameter>)</literal>, but note the reversed
        argument order)
-->
指定した部分文字列の位置を特定します（<literal>position(<parameter>substring</parameter> in <parameter>string</parameter>)</literal> と同じですが、引数の順序が逆になっていることに注意してください）。
       </entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substr</primary>
        </indexterm>
        <literal><function>substr(<parameter>string</parameter>, <parameter>from</parameter> <optional>, <parameter>count</parameter></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Extract substring (same as
        <literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)
-->
指定した部分文字列を取り出します（<literal>substring(<parameter>string</parameter> from <parameter>from</parameter> for <parameter>count</parameter>)</literal>と同じです）。
       </entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>starts_with</primary>
        </indexterm>
        <literal><function>starts_with(<parameter>string</parameter>, <parameter>prefix</parameter>)</function></literal>
       </entry>
       <entry><type>bool</type></entry>
       <entry>
<!--
        Returns true if <parameter>string</parameter> starts with <parameter>prefix</parameter>.
-->
<parameter>string</parameter>が<parameter>prefix</parameter>で始まっていれば真を返します。
       </entry>
       <entry><literal>starts_with('alphabet', 'alph')</literal></entry>
       <entry><literal>t</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_ascii</primary>
        </indexterm>
        <literal><function>to_ascii(<parameter>string</parameter> <type>text</type>
        <optional>, <parameter>encoding</parameter> <type>text</type></optional>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
       Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from another encoding
       (only supports conversion from  <literal>LATIN1</literal>, <literal>LATIN2</literal>, <literal>LATIN9</literal>,
       and <literal>WIN1250</literal> encodings)
-->
<parameter>string</parameter>を他の符号化方式から<acronym>ASCII</acronym>に変換します（<literal>LATIN1</literal>、<literal>LATIN2</literal>、<literal>LATIN9</literal>、<literal>WIN1250</literal>符号化方式からの変換のみをサポートします。）
       </entry>
       <entry><literal>to_ascii('Karel')</literal></entry>
       <entry><literal>Karel</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>to_hex</primary>
        </indexterm>
        <literal><function>to_hex(<parameter>number</parameter> <type>int</type>
        or <type>bigint</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
<!--
       <entry>Convert <parameter>number</parameter> to its equivalent hexadecimal
        representation
-->
       <entry><parameter>number</parameter>を、同等の16進数表現に変換します。
       </entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>translate</primary>
        </indexterm>
        <literal><function>translate(<parameter>string</parameter> <type>text</type>,
        <parameter>from</parameter> <type>text</type>,
        <parameter>to</parameter> <type>text</type>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
<!--
        Any character in <parameter>string</parameter> that matches a
        character in the <parameter>from</parameter> set is replaced by
        the corresponding character in the <parameter>to</parameter>
        set. If <parameter>from</parameter> is longer than
        <parameter>to</parameter>, occurrences of the extra characters in
        <parameter>from</parameter> are removed.
-->
<parameter>from</parameter>集合内の文字と一致する<parameter>string</parameter>にある全ての文字は、<parameter>to</parameter>集合内のそれに対応する文字に置き換えられます。
もし<parameter>from</parameter>が<parameter>to</parameter>より長い場合、<parameter>from</parameter>で指定される余分な文字に一致するものは削除されます。
       </entry>
       <entry><literal>translate('12345', '143', 'ax')</literal></entry>
       <entry><literal>a2x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The <function>concat</function>, <function>concat_ws</function> and
    <function>format</function> functions are variadic, so it is possible to
    pass the values to be concatenated or formatted as an array marked with
    the <literal>VARIADIC</literal> keyword (see <xref
    linkend="xfunc-sql-variadic-functions"/>).  The array's elements are
    treated as if they were separate ordinary arguments to the function.
    If the variadic array argument is NULL, <function>concat</function>
    and <function>concat_ws</function> return NULL, but
    <function>format</function> treats a NULL as a zero-element array.
-->
<function>concat</function>、<function>concat_ws</function>および<function>format</function>関数はVariadicです。従って、キーワード<literal>VARIADIC</literal>で標しをつけられた配列のように、値を連結またはフォーマットした形で受け渡すことが可能です（<xref linkend="xfunc-sql-variadic-functions"/>を参照してください）。
配列の要素は関数に対して分割された通常の引数のように扱われます。
もしvariadic配列引数がNULLであれば、<function>concat</function>および<function>concat_ws</function>はNULLを返しますが、<function>format</function>はNULLを要素を持たない配列と扱います。
   </para>

   <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/>.
-->
<xref linkend="functions-aggregate"/>内の<function>string_agg</function>集約関数も参照してください。
   </para>

   <table id="conversion-names">
<!--
    <title>Built-in Conversions</title>
-->
    <title>組み込みの変換</title>
    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Conversion Name
-->
       <entry>変換名
        <footnote>
         <para>
<!--
          The conversion names follow a standard naming scheme: The
          official name of the source encoding with all
          non-alphanumeric characters replaced by underscores, followed
          by <literal>_to_</literal>, followed by the similarly processed
          destination encoding name. Therefore, the names might deviate
          from the customary encoding names.
-->
変換名は、標準命名体系に従っています。変換元符号化方式の公式名の内、英数字以外の文字をアンダースコアで置き換え、その後に<literal>_to_</literal>を付け、そして変換先符号化方式名を同様に処理したものを続けたものです。
したがって、これらの名称は慣習的なコード名とは異なる可能性があります。
         </para>
        </footnote>
       </entry>
<!--
       <entry>Source Encoding</entry>
       <entry>Destination Encoding</entry>
-->
       <entry>変換前の符号化方式</entry>
       <entry>変換後の符号化方式</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_u_to_utf8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1258_to_utf8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_ascii</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_big5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_cn</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jp</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_kr</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_tw</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gb18030</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_gbk</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_1</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_10</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_13</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_14</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_15</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_16</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_2</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_3</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_4</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_5</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_6</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_7</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_8</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_iso_8859_9</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_johab</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_r</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_koi8_u</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>KOI8U</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_sjis</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1258</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1258</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_uhc</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1253</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1253</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1254</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1254</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1255</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1255</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_1257</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN1257</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_866</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_windows_874</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf8</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1252_to_utf8</literal></entry>
       <entry><literal>WIN1252</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>KOI8R</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf8</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>WIN866</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_utf8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_euc_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_utf8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
      </row>

      <row>
       <entry><literal>utf8_to_shift_jis_2004</literal></entry>
       <entry><literal>UTF8</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jis_2004_to_shift_jis_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
      </row>

      <row>
       <entry><literal>shift_jis_2004_to_euc_jis_2004</literal></entry>
       <entry><literal>SHIFT_JIS_2004</literal></entry>
       <entry><literal>EUC_JIS_2004</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <sect2 id="functions-string-format">
    <title><function>format</function></title>

    <indexterm>
     <primary>format</primary>
    </indexterm>

    <para>
<!--
     The function <function>format</function> produces output formatted according to
     a format string, in a style similar to the C function
     <function>sprintf</function>.
-->
関数<function>format</function>は、C関数の<function>sprintf</function>同様の形式で、フォーマット文字列に従ってフォーマットされた出力を生成します。
    </para>

    <para>
<synopsis>
<function>format</function>(<parameter>formatstr</parameter> <type>text</type> [, <parameter>formatarg</parameter> <type>"any"</type> [, ...] ])
</synopsis>
<!--
     <replaceable>formatstr</replaceable> is a format string that specifies how the
     result should be formatted.  Text in the format string is copied
     directly to the result, except where <firstterm>format specifiers</firstterm> are
     used.  Format specifiers act as placeholders in the string, defining how
     subsequent function arguments should be formatted and inserted into the
     result.  Each <replaceable>formatarg</replaceable> argument is converted to text
     according to the usual output rules for its data type, and then formatted
     and inserted into the result string according to the format specifier(s).
-->
<replaceable>formatstr</replaceable>は結果がどのようにフォーマットされるかを指定するフォーマット文字列です。
<firstterm>フォーマット指示子</firstterm>が使用されている箇所を除き、フォーマット文字列のテキストは結果に直接コピーされます。
フォーマット指示子は文字列中のプレースホルダとして振舞い、その後に引き続く関数引数がどのようにフォーマットされ、どのように結果に挿入されるかを定義します。
それぞれの<replaceable>formatarg</replaceable>引数はそのデータ型に対する通常の出力規定に従ってテキストに変換され、その後フォーマット指示子に従って、結果文字列に挿入されます。
    </para>

    <para>
<!--
     Format specifiers are introduced by a <literal>%</literal> character and have
     the form
-->
フォーマット指示子は<literal>%</literal>文字で始まり、以下の形式をとります。
<synopsis>
%[<replaceable>position</replaceable>][<replaceable>flags</replaceable>][<replaceable>width</replaceable>]<replaceable>type</replaceable>
</synopsis>
<!--
     where the component fields are:
-->
ここで要素フィールドとは以下になっています。

     <variablelist>
      <varlistentry>
<!--
       <term><replaceable>position</replaceable> (optional)</term>
-->
       <term><replaceable>position</replaceable> (省略可能)</term>
       <listitem>
        <para>
<!--
         A string of the form <literal><replaceable>n</replaceable>$</literal> where
         <replaceable>n</replaceable> is the index of the argument to print.
         Index 1 means the first argument after
         <replaceable>formatstr</replaceable>.  If the <replaceable>position</replaceable> is
         omitted, the default is to use the next argument in sequence.
-->
形式<literal><replaceable>n</replaceable>$</literal>の文字列で、<replaceable>n</replaceable>は出力する引数のインデックスです。
インデックス１は<replaceable>formatstr</replaceable>の後の最初の引数です。
<replaceable>position</replaceable>が省略されると、一連の中の次の引数がデフォルトとして使用されます。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>flags</replaceable> (optional)</term>
-->
       <term><replaceable>flags</replaceable> (省略可能)</term>
       <listitem>
        <para>
<!--
         Additional options controlling how the format specifier's output is
         formatted.  Currently the only supported flag is a minus sign
         (<literal>-</literal>) which will cause the format specifier's output to be
         left-justified.  This has no effect unless the <replaceable>width</replaceable>
         field is also specified.
-->
フォーマット指示子の出力がどのようにフォーマットされるかを制御する追加の任意の要素です。
現在、サポートされているflagはマイナス記号(<literal>-</literal>)のみで、フォーマット指示子の出力が左詰めになるようにします。
これは<replaceable>width</replaceable>フィールドが同時に指定されていない場合効果はありません。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>width</replaceable> (optional)</term>
-->
       <term><replaceable>width</replaceable> (省略可能)</term>
       <listitem>
        <para>
<!--
         Specifies the <emphasis>minimum</emphasis> number of characters to use to
         display the format specifier's output.  The output is padded on the
         left or right (depending on the <literal>-</literal> flag) with spaces as
         needed to fill the width.  A too-small width does not cause
         truncation of the output, but is simply ignored.  The width may be
         specified using any of the following: a positive integer; an
         asterisk (<literal>*</literal>) to use the next function argument as the
         width; or a string of the form <literal>*<replaceable>n</replaceable>$</literal> to
         use the <replaceable>n</replaceable>th function argument as the width.
-->
フォーマット指示子の出力を表示する<emphasis>最小</emphasis>文字数を指定します。
出力は、幅を満たすのに必要な空白が左または右（flagの<literal>-</literal>による）に埋め込まれます。
幅が小さすぎても出力が切り詰められることはなく、単に無視されます。
幅は次のいずれかでも指定できます。それらは、正の整数、幅としての次の関数引数として使用する星印 (<literal>*</literal>)、または<replaceable>n</replaceable>番目の関数引数を幅として使用する<literal>*<replaceable>n</replaceable>$</literal>という形式の文字列です。
        </para>

        <para>
<!--
         If the width comes from a function argument, that argument is
         consumed before the argument that is used for the format specifier's
         value.  If the width argument is negative, the result is left
         aligned (as if the <literal>-</literal> flag had been specified) within a
         field of length <function>abs</function>(<replaceable>width</replaceable>).
-->
幅を関数引数から取得する場合、その引数はフォーマット指示子の値に使用される引数より先に消費されます。
幅の引数が負の場合、フィールド長<function>abs</function>(<replaceable>width</replaceable>)の範囲内で結果は（あたかもflagで<literal>-</literal>が指定されたように）左詰めになります。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
<!--
       <term><replaceable>type</replaceable> (required)</term>
-->
       <term><replaceable>type</replaceable> (必須)</term>
       <listitem>
        <para>
<!--
         The type of format conversion to use to produce the format
         specifier's output.  The following types are supported:
-->
フォーマット指示子の出力を生成するのに使用されるフォーマット変換の型。
以下の型がサポートされています。
         <itemizedlist>
          <listitem>
           <para>
<!--
            <literal>s</literal> formats the argument value as a simple
            string.  A null value is treated as an empty string.
-->
<literal>s</literal>は引数の値を単純文字列にフォーマットします。
NULL値は空文字列として扱われます。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>I</literal> treats the argument value as an SQL
            identifier, double-quoting it if necessary.
            It is an error for the value to be null (equivalent to
            <function>quote_ident</function>).
-->
<literal>I</literal>は、引数をSQLの識別子として取り扱い、必要ならそれを二重引用符で括ります。
NULL値はエラーです（<function>quote_ident</function>と同等です）。
           </para>
          </listitem>
          <listitem>
           <para>
<!--
            <literal>L</literal> quotes the argument value as an SQL literal.
            A null value is displayed as the string <literal>NULL</literal>, without
            quotes (equivalent to <function>quote_nullable</function>).
-->
<literal>L</literal>は引数値をSQLリテラルとして引用符が付けられます。
NULL値は引用符無しの文字列<literal>NULL</literal>となります（<function>quote_nullable</function>と同等です）。
           </para>
          </listitem>
         </itemizedlist>
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
<!--
     In addition to the format specifiers described above, the special sequence
     <literal>%%</literal> may be used to output a literal <literal>%</literal> character.
-->
上記で説明したフォーマット指示子に加え、特別の並びの<literal>%%</literal>がリテラル<literal>%</literal>文字を出力するために使用することもできます。
    </para>

    <para>
<!--
     Here are some examples of the basic format conversions:
-->
基本的なフォーマット変換の例を幾つか下記に紹介します。

<screen>
SELECT format('Hello %s', 'World');
<lineannotation>Result: </lineannotation><computeroutput>Hello World</computeroutput>

SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, three, %</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\'Reilly');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "Foo bar" VALUES('O''Reilly')</computeroutput>

SELECT format('INSERT INTO %I VALUES(%L)', 'locations', 'C:\Program Files');
<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO locations VALUES('C:\Program Files')</computeroutput>
</screen>
    </para>

    <para>
<!--
     Here are examples using <replaceable>width</replaceable> fields
     and the <literal>-</literal> flag:
-->
<replaceable>width</replaceable>フィールドとflagの<literal>-</literal>を使用した例を以下に示します。

<screen>
SELECT format('|%10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%-10s|', 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>

SELECT format('|%*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', 10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>

SELECT format('|%-*s|', -10, 'foo');
<lineannotation>Result: </lineannotation><computeroutput>|foo       |</computeroutput>
</screen>
    </para>

    <para>
<!--
     These examples show use of <replaceable>position</replaceable> fields:
-->
以下の例は<replaceable>position</replaceable>フィールドの使い方を示しています。

<screen>
SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, one</computeroutput>

SELECT format('|%*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       bar|</computeroutput>

SELECT format('|%1$*2$s|', 'foo', 10, 'bar');
<lineannotation>Result: </lineannotation><computeroutput>|       foo|</computeroutput>
</screen>
    </para>

    <para>
<!--
     Unlike the standard C function <function>sprintf</function>,
     <productname>PostgreSQL</productname>'s <function>format</function> function allows format
     specifiers with and without <replaceable>position</replaceable> fields to be mixed
     in the same format string.  A format specifier without a
     <replaceable>position</replaceable> field always uses the next argument after the
     last argument consumed.
     In addition, the <function>format</function> function does not require all
     function arguments to be used in the format string.
     For example:
-->
標準C関数<function>sprintf</function>とは違って、<productname>PostgreSQL</productname>の<function>format</function>関数は、同一のフォーマット文字列の中で<replaceable>position</replaceable>フィールドがあるフォーマット指示子と、それがないフォーマット指示子の混在を許容します。
<replaceable>position</replaceable>フィールドが無いフォーマット指示子は常に最終の引数が消費された後に次の引数を使用します。
さらに、<function>format</function>関数はフォーマット文字列で使用されるべき全ての関数引数を要求しません。
例を示します。

<screen>
SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');
<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, three</computeroutput>
</screen>
    </para>

    <para>
<!--
     The <literal>%I</literal> and <literal>%L</literal> format specifiers are particularly
     useful for safely constructing dynamic SQL statements.  See
     <xref linkend="plpgsql-quote-literal-example"/>.
-->
<literal>%I</literal> および <literal>%L</literal>のフォーマット指示子は特に動的SQL命令を安全に構築する場合に便利です。
<xref linkend="plpgsql-quote-literal-example"/>を参照してください。
    </para>
   </sect2>

  </sect1>


  <sect1 id="functions-binarystring">
<!--
   <title>Binary String Functions and Operators</title>
-->
   <title>バイナリ文字列関数と演算子</title>

   <indexterm zone="functions-binarystring">
<!--
    <primary>binary data</primary>
    <secondary>functions</secondary>
-->
    <primary>バイナリデータ</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating values of type <type>bytea</type>.
-->
本節では<type>bytea</type>型の値を調べたり操作するための関数と演算子について説明します。
   </para>

   <para>
<!--
    <acronym>SQL</acronym> defines some string functions that use
    key words, rather than commas, to separate
    arguments.  Details are in
    <xref linkend="functions-binarystring-sql"/>.
    <productname>PostgreSQL</productname> also provides versions of these functions
    that use the regular function invocation syntax
    (see <xref linkend="functions-binarystring-other"/>).
-->
<acronym>SQL</acronym>では、引数の区切りにカンマではなくキーワードを使う文字列関数を、いくつか定義しています。
詳細は<xref linkend="functions-binarystring-sql"/>を参照してください。
また<productname>PostgreSQL</productname>は、これらの関数に対して通常の関数呼び出し構文を使用するバージョンを提供します（<xref linkend="functions-string-other"/>を参照してください）。
   </para>

   <note>
<!--
    <para>
     The sample results shown on this page assume that the server parameter
     <link linkend="guc-bytea-output"><varname>bytea_output</varname></link> is set
     to <literal>escape</literal> (the traditional PostgreSQL format).
    </para>
-->
    <para>
このページで示されるサンプル結果は、サーバパラメータである<link linkend="guc-bytea-output"><varname>bytea_output</varname></link>が<literal>escape</literal>に設定されていることを想定しています(この設定はPostgreSQLの伝統的な形式です)。
    </para>
   </note>

   <table id="functions-binarystring-sql">
<!--
    <title><acronym>SQL</acronym> Binary String Functions and Operators</title>
-->
    <title><acronym>SQL</acronym>バイナリ文字列関数と演算子</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>string</parameter> <literal>||</literal>
        <parameter>string</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>
<!--
        String concatenation
-->
        文字列結合
        <indexterm>
<!--
         <primary>binary string</primary>
         <secondary>concatenation</secondary>
-->
         <primary>バイナリ文字列</primary>
         <secondary>結合</secondary>
        </indexterm>
       </entry>
       <entry><literal>'\\Post'::bytea || '\047gres\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres\000</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>octet_length</primary>
        </indexterm>
        <literal><function>octet_length(<parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Number of bytes in binary string</entry>
-->
       <entry>バイナリ文字列中のバイト数</entry>
       <entry><literal>octet_length('jo\000se'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
        <literal><function>overlay(<parameter>string</parameter> placing <parameter>string</parameter> from <type>int</type> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Replace substring
-->
        部分文字列の置換
       </entry>
       <entry><literal>overlay('Th\000omas'::bytea placing '\002\003'::bytea from 2 for 3)</literal></entry>
       <entry><literal>T\\002\\003mas</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>position</primary>
        </indexterm>
        <literal><function>position(<parameter>substring</parameter> in <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
<!--
       <entry>Location of specified substring</entry>
-->
       <entry>指定した部分文字列の位置</entry>
      <entry><literal>position('\000om'::bytea in 'Th\000omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
        <literal><function>substring(<parameter>string</parameter> <optional>from <type>int</type></optional> <optional>for <type>int</type></optional>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Extract substring
-->
        部分文字列の抽出
       </entry>
       <entry><literal>substring('Th\000omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>trim</primary>
        </indexterm>
        <literal><function>trim(<optional>both</optional>
        <parameter>bytes</parameter> from
        <parameter>string</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Remove the longest string containing only bytes appearing in
        <parameter>bytes</parameter> from the start
        and end of <parameter>string</parameter>
-->
文字列<parameter>string</parameter>の先頭および末尾から<parameter>bytes</parameter>に含まれるバイトのみを含む最長の文字列を削除します。
       </entry>
       <entry><literal>trim('\000\001'::bytea from '\000Tom\001'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    Additional binary string manipulation functions are available and
    are listed in <xref linkend="functions-binarystring-other"/>.  Some
    of them are used internally to implement the
    <acronym>SQL</acronym>-standard string functions listed in <xref
    linkend="functions-binarystring-sql"/>.
-->
この他、<xref linkend="functions-binarystring-other"/>に列挙するバイナリ列操作関数が使えます。
そのいくつかは、<xref linkend="functions-binarystring-sql"/>で説明した標準<acronym>SQL</acronym>の文字列関数を実装するために内部的に使用されています。
   </para>

   <table id="functions-binarystring-other">
<!--
    <title>Other Binary String Functions</title>
-->
    <title>その他のバイナリ文字列関数</title>
    <tgroup cols="5">
     <thead>
      <row>
<!--
       <entry>Function</entry>
       <entry>Return Type</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>関数</entry>
       <entry>戻り値型</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <indexterm>
         <primary>btrim</primary>
        </indexterm>
        <literal><function>btrim(<parameter>string</parameter>
        <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Remove the longest string containing only bytes appearing in
        <parameter>bytes</parameter> from the start and end of
        <parameter>string</parameter>
-->
<parameter>bytes</parameter>に含まれるバイトのみを有する最長の文字列を<parameter>string</parameter>の先頭と末尾から削除します。
      </entry>
      <entry><literal>btrim('\000trim\001'::bytea, '\000\001'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>decode</primary>
        </indexterm>
       <literal><function>decode(<parameter>string</parameter> <type>text</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>
<!--
       Decode binary data from textual representation in <parameter>string</parameter>.
       Options for <parameter>format</parameter> are same as in <function>encode</function>.
-->
<parameter>string</parameter>で表現されているテキストデータをバイナリデータに復号します。
<parameter>format</parameter>のオプションは<function>encode</function>と同じです。
      </entry>
      <entry><literal>decode('123\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
        <indexterm>
         <primary>encode</primary>
        </indexterm>
       <literal><function>encode(<parameter>data</parameter> <type>bytea</type>,
       <parameter>format</parameter> <type>text</type>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
<!--
       Encode binary data into a textual representation.  Supported
       formats are: <literal>base64</literal>, <literal>hex</literal>, <literal>escape</literal>.
       <literal>escape</literal> converts zero bytes and high-bit-set bytes to
       octal sequences (<literal>\</literal><replaceable>nnn</replaceable>) and
       doubles backslashes.
-->
バイナリデータをテキスト表現形式に符号化します。
サポートされている形式は、<literal>base64</literal>、<literal>hex</literal>、<literal>escape</literal>です。
<literal>escape</literal>は0のバイトと最上位ビットがセットされているバイトを8進数のシーケンス(<literal>\</literal><replaceable>nnn</replaceable>)に変換し 、バックスラッシュを二重化します。
      </entry>
      <entry><literal>encode('123\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
        <literal><function>get_bit(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Extract bit from string
-->
        文字列から1ビット抽出します。
       </entry>
       <entry><literal>get_bit('Th\000omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
        <literal><function>get_byte(<parameter>string</parameter>, <parameter>offset</parameter>)</function></literal>
       </entry>
       <entry><type>int</type></entry>
       <entry>
<!--
        Extract byte from string
-->
        文字列から1バイト抽出します。
       </entry>
       <entry><literal>get_byte('Th\000omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

     <row>
      <entry>
       <indexterm>
        <primary>length</primary>
       </indexterm>
       <literal><function>length(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>int</type></entry>
      <entry>
<!--
       Length of binary string
-->
       バイナリ文字列の長さ
       <indexterm>
<!--
        <primary>binary string</primary>
        <secondary>length</secondary>
-->
        <primary>バイナリ文字列</primary>
        <secondary>長さ</secondary>
       </indexterm>
       <indexterm>
<!--
        <primary>length</primary>
        <secondary sortas="binary string">of a binary string</secondary>
        <see>binary strings, length</see>
-->
        <primary>長さ</primary>
        <secondary sortas="binary string">バイナリ文字列の</secondary>
        <see>バイナリ文字列, 長さ</see>
       </indexterm>
      </entry>
      <entry><literal>length('jo\000se'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>md5</primary>
       </indexterm>
       <literal><function>md5(<parameter>string</parameter>)</function></literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
<!--
       Calculates the MD5 hash of <parameter>string</parameter>,
       returning the result in hexadecimal
-->
       <parameter>string</parameter>のMD5のハッシュを計算し、結果を16進数で返します。
      </entry>
      <entry><literal>md5('Th\000omas'::bytea)</literal></entry>
      <entry><literal>8ab2d3c9689aaf18&#x200B;b4958c334c82d8b1</literal></entry>
     </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
        <literal><function>set_bit(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Set bit in string
-->
        文字列内のビットを設定します。
       </entry>
       <entry><literal>set_bit('Th\000omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
        <literal><function>set_byte(<parameter>string</parameter>,
        <parameter>offset</parameter>, <parameter>newvalue</parameter>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        Set byte in string
-->
        文字列内の1バイトを設定します。
       </entry>
       <entry><literal>set_byte('Th\000omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha224</primary>
        </indexterm>
        <literal><function>sha224(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-224 hash
-->
SHA-224ハッシュ
       </entry>
       <entry><literal>sha224('abc')</literal></entry>
       <entry><literal>\x23097d223405d8228642a477bda2&#x200B;55b32aadbce4bda0b3f7e36c9da7</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha256</primary>
        </indexterm>
        <literal><function>sha256(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-256 hash
-->
SHA-256ハッシュ
       </entry>
       <entry><literal>sha256('abc')</literal></entry>
       <entry><literal>\xba7816bf8f01cfea414140de5dae2223&#x200B;b00361a396177a9cb410ff61f20015ad</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha384</primary>
        </indexterm>
        <literal><function>sha384(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-384 hash
-->
SHA-384ハッシュ
       </entry>
       <entry><literal>sha384('abc')</literal></entry>
       <entry><literal>\xcb00753f45a35e8bb5a03d699ac65007&#x200B;272c32ab0eded1631a8b605a43ff5bed&#x200B;8086072ba1e7cc2358baeca134c825a7</literal></entry>
      </row>

      <row>
       <entry>
        <indexterm>
         <primary>sha512</primary>
        </indexterm>
        <literal><function>sha512(<type>bytea</type>)</function></literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
<!--
        SHA-512 hash
-->
SHA-512ハッシュ
       </entry>
       <entry><literal>sha512('abc')</literal></entry>
       <entry><literal>\xddaf35a193617abacc417349ae204131&#x200B;12e6fa4e89a97ea20a9eeee64b55d39a&#x200B;2192992a274fc1a836ba3c23a3feebbd&#x200B;454d4423643ce80e2a9ac94fa54ca49f</literal></entry>
      </row>
    </tbody>
   </tgroup>
  </table>

  <para>
<!--
   <function>get_byte</function> and <function>set_byte</function> number the first byte
   of a binary string as byte 0.
   <function>get_bit</function> and <function>set_bit</function> number bits from the
   right within each byte; for example bit 0 is the least significant bit of
   the first byte, and bit 15 is the most significant bit of the second byte.
-->
<function>get_byte</function>と<function>set_byte</function>はバイナリ列の先頭バイトを0バイトとして数えます。
<function>get_bit</function>と<function>set_bit</function>は各バイト内を右からビットを数えます。例えばビット0は先頭バイトの最下位ビットとなり、ビット15は第二バイトの最上位ビットとなります。
  </para>

  <para>
<!--
   Note that for historic reasons, the function <function>md5</function>
   returns a hex-encoded value of type <type>text</type> whereas the SHA-2
   functions return type <type>bytea</type>.  Use the functions
   <function>encode</function> and <function>decode</function> to convert
   between the two, for example <literal>encode(sha256('abc'),
   'hex')</literal> to get a hex-encoded text representation.
-->
歴史的な理由により、<function>md5</function>は16進のエンコード値を返すのに対し、SHA-2関数は<type>bytea</type>を返すことに注意してください。
両者の間の変換を行うには、関数<function>encode</function>と<function>decode</function>を使ってください。たとえば、16進のエンコードのテキスト表現を得るには、<literal>encode(sha256('abc'),'hex')</literal>としてください。
  </para>

  <para>
<!--
   See also the aggregate function <function>string_agg</function> in
   <xref linkend="functions-aggregate"/> and the large object functions
   in <xref linkend="lo-funcs"/>.
-->
<xref linkend="functions-aggregate"/>における<function>string_agg</function>集約関数や<xref linkend="lo-funcs"/>のラージオブジェクト関数も参照してください。
  </para>
 </sect1>


  <sect1 id="functions-bitstring">
<!--
   <title>Bit String Functions and Operators</title>
-->
   <title>ビット文字列関数と演算子</title>

   <indexterm zone="functions-bitstring">
<!--
    <primary>bit strings</primary>
    <secondary>functions</secondary>
-->
    <primary>ビット文字列</primary>
    <secondary>関数</secondary>
   </indexterm>

   <para>
<!--
    This section describes functions and operators for examining and
    manipulating bit strings, that is values of the types
    <type>bit</type> and <type>bit varying</type>.  Aside from the
    usual comparison operators, the operators
    shown in <xref linkend="functions-bit-string-op-table"/> can be used.
    Bit string operands of <literal>&amp;</literal>, <literal>|</literal>,
    and <literal>#</literal> must be of equal length.  When bit
    shifting, the original length of the string is preserved, as shown
    in the examples.
-->
本節では、ビット文字列の検査と操作を行う関数と演算子について説明します。ビット文字列とは、<type>bit</type>型と<type>bit varying</type>型の値のことです。
通常の比較演算子に加え、<xref linkend="functions-bit-string-op-table"/>に示す演算子も使用可能です。
<literal>&amp;</literal>、<literal>|</literal>、<literal>#</literal>のビット文字列オペランドは同一長でなければなりません。
ビットシフト処理の際、例に示す通り元の長さは保持されます。
   </para>

   <table id="functions-bit-string-op-table">
<!--
    <title>Bit String Operators</title>
-->
    <title>ビット文字列演算子</title>

    <tgroup cols="4">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
       <entry>Result</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
       <entry>例</entry>
       <entry>結果</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
<!--
       <entry>concatenation</entry>
-->
       <entry>結合</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
<!--
       <entry>bitwise AND</entry>
-->
       <entry>ビットのAND</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
<!--
       <entry>bitwise OR</entry>
-->
       <entry>ビットのOR</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
<!--
       <entry>bitwise XOR</entry>
-->
       <entry>ビットのXOR</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
<!--
       <entry>bitwise NOT</entry>
-->
       <entry>ビットのNOT</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
<!--
       <entry>bitwise shift left</entry>
-->
       <entry>ビットの左シフト</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
<!--
       <entry>bitwise shift right</entry>
-->
       <entry>ビットの右シフト</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
<!--
    The following <acronym>SQL</acronym>-standard functions work on bit
    strings as well as character strings:
    <literal><function>length</function></literal>,
    <literal><function>bit_length</function></literal>,
    <literal><function>octet_length</function></literal>,
    <literal><function>position</function></literal>,
    <literal><function>substring</function></literal>,
    <literal><function>overlay</function></literal>.
-->
次の標準<acronym>SQL</acronym>関数は文字列同様にビット文字列で動作します。
    <literal><function>length</function></literal>、
    <literal><function>bit_length</function></literal>、
    <literal><function>octet_length</function></literal>、
    <literal><function>position</function></literal>、
    <literal><function>substring</function></literal>、
    <literal><function>overlay</function></literal>。
   </para>

   <para>
<!--
    The following functions work on bit strings as well as binary
    strings:
    <literal><function>get_bit</function></literal>,
    <literal><function>set_bit</function></literal>.
-->
次の関数はバイナリ同様にビット文字列で動作します。
    <literal><function>get_bit</function></literal>、
    <literal><function>set_bit</function></literal>。
<!--
    When working with a bit string, these functions number the first
    (leftmost) bit of the string as bit 0.
-->
ビット文字列に処理を行った場合、これらの関数は文字列の最初(一番左)のビットを0として数えます。
   </para>

   <para>
<!--
    In addition, it is possible to cast integral values to and from type
    <type>bit</type>.
    Some examples:
-->
さらに、<type>bit</type>型から整数値にキャストすることも整数から<type>bit</type>型にキャストすることも可能です。
以下に例を示します。
<programlisting>
44::bit(10)                    <lineannotation>0000101100</lineannotation>
44::bit(3)                     <lineannotation>100</lineannotation>
cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>
'1110'::bit(4)::integer        <lineannotation>14</lineannotation>
</programlisting>
<!--
    Note that casting to just <quote>bit</quote> means casting to
    <literal>bit(1)</literal>, and so will deliver only the least significant
    bit of the integer.
-->
単に<quote>bit</quote>にキャストすることは<literal>bit(1)</literal>にキャストすることを意味することに注意してください。つまり、単に整数の最下位ビットのみが渡されることになります。
   </para>

    <note>
     <para>
<!--
      Casting an integer to <type>bit(n)</type> copies the rightmost
      <literal>n</literal> bits.  Casting an integer to a bit string width wider
      than the integer itself will sign-extend on the left.
-->
整数を<type>bit(n)</type>にキャストすると、整数の最下位ビットから<literal>n</literal>ビット分複写されます。
整数からビット数が元の整数より多いビット文字列にキャストする際、符号ビットでその左部分を拡張します。
     </para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
<!--
  <title>Pattern Matching</title>
-->
  <title>パターンマッチ</title>

  <indexterm zone="functions-matching">
<!--
   <primary>pattern matching</primary>
-->
   <primary>パターンマッチ</primary>
  </indexterm>

   <para>
<!--
    There are three separate approaches to pattern matching provided
    by <productname>PostgreSQL</productname>: the traditional
    <acronym>SQL</acronym> <function>LIKE</function> operator, the
    more recent <function>SIMILAR TO</function> operator (added in
    SQL:1999), and <acronym>POSIX</acronym>-style regular
    expressions.  Aside from the basic <quote>does this string match
    this pattern?</quote> operators, functions are available to extract
    or replace matching substrings and to split a string at matching
    locations.
-->
<productname>PostgreSQL</productname>には、パターンマッチを行うに際して3つの異なった手法があります。伝統的な<acronym>SQL</acronym>の<function>LIKE</function>演算子、これより新しい<function>SIMILAR TO</function>演算子（SQL:1999で追加されました）、および<acronym>POSIX</acronym>様式の正規表現です。
基本の<quote>この文字列はこのパターンに一致するか？</quote>を別としても、一致した部分文字列を取り出したり置換したり、そして一致部分で文字列を分割する関数が用意されています。
   </para>

   <tip>
    <para>
<!--
     If you have pattern matching needs that go beyond this,
     consider writing a user-defined function in Perl or Tcl.
-->
上記の手法では検索できないようなパターンマッチが必要な場合は、PerlもしくはTclでユーザ定義関数を作成することを検討してください。
    </para>
   </tip>

   <caution>
    <para>
<!--
     While most regular-expression searches can be executed very quickly,
     regular expressions can be contrived that take arbitrary amounts of
     time and memory to process.  Be wary of accepting regular-expression
     search patterns from hostile sources.  If you must do so, it is
     advisable to impose a statement timeout.
-->
ほとんどの正規表現検索はとても速く実行されますが、正規表現は処理するのに任意の時間とメモリを使う可能性があります。
悪意のあるソースから正規表現検索パターンを受け取ることに用心してください。
そうしなければならないのであれば、文のタイムアウトを強制するのが賢明です。
    </para>

    <para>
<!--
     Searches using <function>SIMILAR TO</function> patterns have the same
     security hazards, since <function>SIMILAR TO</function> provides many
     of the same capabilities as <acronym>POSIX</acronym>-style regular
     expressions.
-->
<function>SIMILAR TO</function>が<acronym>POSIX</acronym>書式の正規表現と同じ多くの機能を提供するので、<function>SIMILAR TO</function>パターンを使う検索は同様のセキュリティ問題を抱えています。
    </para>

    <para>
<!--
     <function>LIKE</function> searches, being much simpler than the other
     two options, are safer to use with possibly-hostile pattern sources.
-->
<function>LIKE</function>検索は、他の2つの方法よりずっと単純ですので、悪意があるかもしれないパターンのソースで使うのにはより安全です。
    </para>
   </caution>

   <para>
<!--
    The pattern matching operators of all three kinds do not support
    nondeterministic collations.  If required, apply a different collation to
    the expression to work around this limitation.
-->
この3種類のパターンマッチング演算子はどれも非決定的照合順序をサポートしていません。
必要なら、この制限事項に対応するために別の照合順序を式に適用してください。
   </para>

  <sect2 id="functions-like">
   <title><function>LIKE</function></title>

   <indexterm>
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT LIKE <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

    <para>
<!--
     The <function>LIKE</function> expression returns true if the
     <replaceable>string</replaceable> matches the supplied
     <replaceable>pattern</replaceable>.  (As
     expected, the <function>NOT LIKE</function> expression returns
     false if <function>LIKE</function> returns true, and vice versa.
     An equivalent expression is
     <literal>NOT (<replaceable>string</replaceable> LIKE
      <replaceable>pattern</replaceable>)</literal>.)
-->
<function>LIKE</function>式は供給された<replaceable>pattern</replaceable>に<replaceable>string</replaceable>が一致すれば真を返します。
（想像される通り、<function>NOT LIKE</function>式は<function>LIKE</function>式が真を返す場合には偽を返し、その逆もまた同じです。
同等の式として<literal>NOT (<replaceable>string</replaceable> LIKE <replaceable>pattern</replaceable>)</literal>とも表現できます。）
    </para>

    <para>
<!--
     If <replaceable>pattern</replaceable> does not contain percent
     signs or underscores, then the pattern only represents the string
     itself; in that case <function>LIKE</function> acts like the
     equals operator.  An underscore (<literal>_</literal>) in
     <replaceable>pattern</replaceable> stands for (matches) any single
     character; a percent sign (<literal>%</literal>) matches any sequence
     of zero or more characters.
-->
<replaceable>pattern</replaceable>がパーセント記号もしくはアンダースコアを含んでいない場合patternは自身の文字列そのものです。この場合<function>LIKE</function>式は等号演算子のように振舞います。
<replaceable>pattern</replaceable>の中にあるアンダースコア（<literal>_</literal>）は任意の一文字との一致を意味し、パーセント記号（<literal>%</literal>）は0文字以上の並びとの一致を意味します。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' LIKE 'abc'    <lineannotation>true</lineannotation>
'abc' LIKE 'a%'     <lineannotation>true</lineannotation>
'abc' LIKE '_b_'    <lineannotation>true</lineannotation>
'abc' LIKE 'c'      <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    <function>LIKE</function> pattern matching always covers the entire
    string.  Therefore, if it's desired to match a sequence anywhere within
    a string, the pattern must start and end with a percent sign.
-->
<function>LIKE</function>によるパターン一致は常に文字列全体に対して行われます。
従って、文字列内の任意位置における並びと一致させたい場合には、パーセント記号を先頭と末尾に付ける必要があります。
   </para>

   <para>
<!--
    To match a literal underscore or percent sign without matching
    other characters, the respective character in
    <replaceable>pattern</replaceable> must be
    preceded by the escape character.  The default escape
    character is the backslash but a different one can be selected by
    using the <literal>ESCAPE</literal> clause.  To match the escape
    character itself, write two escape characters.
-->
他の文字の一致に使用するのではなく、アンダースコアやパーセント記号そのものを一致させたい場合には、<replaceable>pattern</replaceable>の中のそれぞれのアンダースコアとパーセント記号の前にエスケープ文字を付けなければなりません。
デフォルトのエスケープ文字はバックスラッシュですが、<literal>ESCAPE</literal>句で他の文字を指定することができます。エスケープ文字そのものを一致させるにはエスケープ文字を2つ書きます。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
-->
<xref linkend="guc-standard-conforming-strings"/>パラメータをoffにしている場合、リテラル文字列定数に記述するバックスラッシュを二重にする必要があります。
詳細は<xref linkend="sql-syntax-strings"/>を参照してください。
    </para>
   </note>

   <para>
<!--
    It's also possible to select no escape character by writing
    <literal>ESCAPE ''</literal>.  This effectively disables the
    escape mechanism, which makes it impossible to turn off the
    special meaning of underscore and percent signs in the pattern.
-->
同時に<literal>ESCAPE ''</literal>と記述することでエスケープ文字を選択しないことも可能です。
これにより、事実上エスケープ機構が働かなくなります。つまり、パターン内のアンダースコアおよびパーセント記号の特別な意味を解除することはできなくなります。
   </para>

   <para>
<!--
    The key word <token>ILIKE</token> can be used instead of
    <token>LIKE</token> to make the match case-insensitive according
    to the active locale.  This is not in the <acronym>SQL</acronym> standard but is a
    <productname>PostgreSQL</productname> extension.
-->
現在のロケールに従って大文字小文字を区別しない一致を行うのであれば、<token>LIKE</token>の代わりに<token>ILIKE</token>キーワードを使うことができます。
これは標準<acronym>SQL</acronym>ではなく、<productname>PostgreSQL</productname>の拡張です。
   </para>

   <para>
<!--
    The operator <literal>~~</literal> is equivalent to
    <function>LIKE</function>, and <literal>~~*</literal> corresponds to
    <function>ILIKE</function>.  There are also
    <literal>!~~</literal> and <literal>!~~*</literal> operators that
    represent <function>NOT LIKE</function> and <function>NOT
    ILIKE</function>, respectively.  All of these operators are
    <productname>PostgreSQL</productname>-specific.  You may see these
    operator names in <command>EXPLAIN</command> output and similar
    places, since the parser actually translates <function>LIKE</function>
    et al. to these operators.
-->
<literal>~~</literal>演算子は<function>LIKE</function>式と等価で、<literal>~~*</literal>は<function>ILIKE</function>に対応します。
また<function>NOT LIKE</function>および<function>NOT ILIKE</function>を表す<literal>!~~</literal>および<literal>!~~*</literal>演算子があります。
これら全ての演算子は<productname>PostgreSQL</productname>固有のものです。
パーサは実際には<function>LIKE</function>などをこれらの演算子に変換するため、こうした演算子名は<command>EXPLAIN</command>の出力などで見ることができます。
   </para>

   <para>
<!--
    The phrases <function>LIKE</function>, <function>ILIKE</function>,
    <function>NOT LIKE</function>, and <function>NOT ILIKE</function> are
    generally treated as operators
    in <productname>PostgreSQL</productname> syntax; for example they can
    be used in <replaceable>expression</replaceable>
    <replaceable>operator</replaceable> ANY
    (<replaceable>subquery</replaceable>) constructs, although
    an <literal>ESCAPE</literal> clause cannot be included there.  In some
    obscure cases it may be necessary to use the underlying operator names
    instead.
-->
<function>LIKE</function>、<function>ILIKE</function>、<function>NOT LIKE</function>、<function>NOT ILIKE</function>句は一般に<productname>PostgreSQL</productname>の構文上は演算子として扱われます。
たとえば、<replaceable>式</replaceable> <replaceable>演算子</replaceable> ANY(<replaceable>副問い合わせ</replaceable>)構文で使用できます。しかし、<literal>ESCAPE</literal>句はこれには含むことはできません。
状況によっては背後の演算子名を代わりに使わなければならない場合もあります。
   </para>

   <para>
<!--
    There is also the prefix operator <literal>^@</literal> and corresponding
    <function>starts_with</function> function which covers cases when only
    searching by beginning of the string is needed.
-->
単に文字列の先頭からの開始が必要なだけのケースであれば、接頭辞演算子<literal>^@</literal>とそれに対応する<function>starts_with</function>関数もあります。
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
<!--
   <title><function>SIMILAR TO</function> Regular Expressions</title>
-->
   <title><function>SIMILAR TO</function>正規表現</title>

   <indexterm>
<!--
    <primary>regular expression</primary>
-->
    <primary>正規表現</primary>
    <!-- 原文コメント <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>

<synopsis>
<replaceable>string</replaceable> SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
<replaceable>string</replaceable> NOT SIMILAR TO <replaceable>pattern</replaceable> <optional>ESCAPE <replaceable>escape-character</replaceable></optional>
</synopsis>

   <para>
<!--
    The <function>SIMILAR TO</function> operator returns true or
    false depending on whether its pattern matches the given string.
    It is similar to <function>LIKE</function>, except that it
    interprets the pattern using the SQL standard's definition of a
    regular expression.  SQL regular expressions are a curious cross
    between <function>LIKE</function> notation and common regular
    expression notation.
-->
<function>SIMILAR TO</function>演算子は、そのパターンが与えられた文字列に一致するかどうかにより、真もしくは偽を返します。
これは、標準SQLの正規表現定義を使用してパターンを解釈するという点以外は、<function>LIKE</function>に類似しています。
SQLの正規表現は、<function>LIKE</function>表記と一般的な正規表現の表記とを混ぜ合わせたようなものになっています。
   </para>

   <para>
<!--
    Like <function>LIKE</function>, the <function>SIMILAR TO</function>
    operator succeeds only if its pattern matches the entire string;
    this is unlike common regular expression behavior where the pattern
    can match any part of the string.
    Also like
    <function>LIKE</function>, <function>SIMILAR TO</function> uses
    <literal>_</literal> and <literal>%</literal> as wildcard characters denoting
    any single character and any string, respectively (these are
    comparable to <literal>.</literal> and <literal>.*</literal> in POSIX regular
    expressions).
-->
<function>LIKE</function>と同様、<function>SIMILAR TO</function>演算子は、そのパターンが文字列全体に一致した場合のみ真を返します。これは、パターンが文字列の一部分であっても一致する、一般的な正規表現の動作とは異なっています。
また、<function>LIKE</function>と同様、<function>SIMILAR TO</function>では、<literal>%</literal>および<literal>_</literal>を、それぞれ任意の文字列および任意の単一文字を意味するワイルドカード文字として使用します（これらは、POSIX正規表現での<literal>.*</literal>および<literal>.</literal>に相当します）。
   </para>

   <para>
<!--
    In addition to these facilities borrowed from <function>LIKE</function>,
    <function>SIMILAR TO</function> supports these pattern-matching
    metacharacters borrowed from POSIX regular expressions:
-->
<function>LIKE</function>から取り入れた上記の機能に加え、<function>SIMILAR TO</function>では、以下のようにPOSIX正規表現から取り入れたパターンマッチメタ文字もサポートしています。

   <itemizedlist>
    <listitem>
     <para>
<!--
      <literal>|</literal> denotes alternation (either of two alternatives).
-->
<literal>|</literal>は、二者択一（2つの選択肢のうちいずれか）を意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>*</literal> denotes repetition of the previous item zero
      or more times.
-->
<literal>*</literal>は、直前の項目の0回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>+</literal> denotes repetition of the previous item one
      or more times.
-->
<literal>+</literal>は、直前の項目の1回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>?</literal> denotes repetition of the previous item zero
      or one time.
-->
<literal>?</literal>は、直前の項目の0回もしくは1回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes repetition
      of the previous item exactly <replaceable>m</replaceable> times.
-->
<literal>{</literal><replaceable>m</replaceable><literal>}</literal>は、直前の項目の正確な<replaceable>m</replaceable>回の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> denotes repetition
      of the previous item <replaceable>m</replaceable> or more times.
-->
      <literal>{</literal><replaceable>m</replaceable><literal>,}</literal>は、直前の項目の<replaceable>m</replaceable>回以上の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
      denotes repetition of the previous item at least <replaceable>m</replaceable> and
      not more than <replaceable>n</replaceable> times.
-->
<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>は、直前の項目の<replaceable>m</replaceable>回以上かつ<replaceable>n</replaceable>回以下の繰り返しを意味します。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      Parentheses <literal>()</literal> can be used to group items into
      a single logical item.
-->
丸括弧<literal>()</literal>は、項目を1つの論理項目にグループ化することができます。
     </para>
    </listitem>
    <listitem>
     <para>
<!--
      A bracket expression <literal>[...]</literal> specifies a character
      class, just as in POSIX regular expressions.
-->
大括弧式<literal>[...]</literal>は、POSIX正規表現と同様に文字クラスを指定します。
     </para>
    </listitem>
   </itemizedlist>

<!--
    Notice that the period (<literal>.</literal>) is not a metacharacter
    for <function>SIMILAR TO</function>.
-->
<function>SIMILAR TO</function>ではピリオド（<literal>.</literal>）はメタ文字ではないことに注意してください。
   </para>

   <para>
<!--
    As with <function>LIKE</function>, a backslash disables the special meaning
    of any of these metacharacters; or a different escape character can
    be specified with <literal>ESCAPE</literal>.
-->
<function>LIKE</function>と同様、バックスラッシュは全てのメタ文字の特殊な意味を無効にします。
また、異なるエスケープ文字を<literal>ESCAPE</literal>で指定することが可能です。
   </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>
'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>
'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>
'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>
</programlisting>
   </para>

   <para>
<!--
    The <function>substring</function> function with three parameters
    provides extraction of a substring that matches an SQL
    regular expression pattern.  The function can be written according
    to SQL99 syntax:
-->
3つのパラメータを持つ<function>substring</function>関数を使用して、SQL正規表現パターンに一致する部分文字列を取り出すことができます。
SQL99の構文にしたがって、この関数は次のように書くことができます。
<synopsis>
substring(<replaceable>string</replaceable> from <replaceable>pattern</replaceable> for <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    or as a plain three-argument function:
-->
あるいは単なる3引数関数として次のように書くこともできます。
<synopsis>
substring(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>, <replaceable>escape-character</replaceable>)
</synopsis>
<!--
    As with <literal>SIMILAR TO</literal>, the
    specified pattern must match the entire data string, or else the
    function fails and returns null.  To indicate the part of the
    pattern for which the matching data sub-string is of interest,
    the pattern should contain
    two occurrences of the escape character followed by a double quote
    (<literal>"</literal>). <!&#045;- 原文コメント " font-lock sanity &#045;->
    The text matching the portion of the pattern
    between these separators is returned when the match is successful.
-->
<literal>SIMILAR TO</literal>と同様、指定したパターンがデータ文字列全体に一致する必要があります。一致しない場合、関数は失敗し、NULLを返します。
マッチするデータのうちの対象とする部分文字列に対応するパターンの部分を示すために、エスケープ文字の後に二重引用符（<literal>"</literal>）を繋げたものを2つパターンに含める必要があります。<!-- " font-lock sanity -->
マッチが成功すると、これらの印で括られたパターンの一部に一致するテキストが返されます。
   </para>

   <para>
<!--
    The escape-double-quote separators actually
    divide <function>substring</function>'s pattern into three independent
    regular expressions; for example, a vertical bar (<literal>|</literal>)
    in any of the three sections affects only that section.  Also, the first
    and third of these regular expressions are defined to match the smallest
    possible amount of text, not the largest, when there is any ambiguity
    about how much of the data string matches which pattern.  (In POSIX
    parlance, the first and third regular expressions are forced to be
    non-greedy.)
-->
エスケープ文字と二重引用符による区切りは実際には<function>substring</function>のパターン引数を3つの独立した正規表現に分割します。
たとえば3つのセクションのどこかに置いた垂直線（<literal>|</literal>）はそのセクションにしか影響を及ぼしません。
また、どのパターンにデータ文字列がマッチするかについて曖昧さがある場合は、最初と3番目の正規表現は、可能な最大のテキストではなく、最小のテキストにマッチするものとして定義されます。
（POSIX用語では、最初と3番目の正規表現は非貪欲（non-greedy）に強制されます。）
   </para>

   <para>
<!--
    As an extension to the SQL standard, <productname>PostgreSQL</productname>
    allows there to be just one escape-double-quote separator, in which case
    the third regular expression is taken as empty; or no separators, in which
    case the first and third regular expressions are taken as empty.
-->
SQL標準への拡張として、<productname>PostgreSQL</productname>は、二重引用符による区切りが一個だけ存在することを許容し、その場合は3番目の正規表現が空として扱われます。
あるいは、二重引用符による区切りがないことも許容し、その場合は最初と3番目の正規表現は空として扱われます。
   </para>

   <para>
<!--
    Some examples, with <literal>#&quot;</literal> delimiting the return string:
-->
例：<literal>#&quot;</literal>を使用して返される文字列を区切ります。
<programlisting>
substring('foobar' from '%#"o_b#"%' for '#')   <lineannotation>oob</lineannotation>
substring('foobar' from '#"o_b#"%' for '#')    <lineannotation>NULL</lineannotation>
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
<!--
   <title><acronym>POSIX</acronym> Regular Expressions</title>
-->
   <title><acronym>POSIX</acronym>正規表現</title>

   <indexterm zone="functions-posix-regexp">
<!--
    <primary>regular expression</primary>
    <seealso>pattern matching</seealso>
-->
    <primary>正規表現</primary>
    <seealso>パターンマッチ</seealso>
   </indexterm>
   <indexterm>
    <primary>substring</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_replace</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_match</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_matches</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_table</primary>
   </indexterm>
   <indexterm>
    <primary>regexp_split_to_array</primary>
   </indexterm>

   <para>
<!--
    <xref linkend="functions-posix-table"/> lists the available
    operators for pattern matching using POSIX regular expressions.
-->
<xref linkend="functions-posix-table"/>に、POSIX正規表現を使ったパターンマッチに使用可能な演算子を列挙します。
   </para>

   <table id="functions-posix-table">
<!--
    <title>Regular Expression Match Operators</title>
-->
    <title>正規表現マッチ演算子</title>

    <tgroup cols="3">
     <thead>
      <row>
<!--
       <entry>Operator</entry>
       <entry>Description</entry>
       <entry>Example</entry>
-->
       <entry>演算子</entry>
       <entry>説明</entry>
       <entry>例</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
<!--
        <entry>Matches regular expression, case sensitive</entry>
-->
        <entry>正規表現にマッチ、大文字小文字の区別あり</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
<!--
        <entry>Matches regular expression, case insensitive</entry>
-->
        <entry>正規表現にマッチ、大文字小文字の区別なし</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
<!--
        <entry>Does not match regular expression, case sensitive</entry>
-->
        <entry>正規表現にマッチしない、大文字小文字の区別あり</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
<!--
        <entry>Does not match regular expression, case insensitive</entry>
-->
        <entry>正規表現にマッチしない、大文字小文字の区別なし</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
<!--
     <acronym>POSIX</acronym> regular expressions provide a more
     powerful means for pattern matching than the <function>LIKE</function> and
     <function>SIMILAR TO</function> operators.
     Many Unix tools such as <command>egrep</command>,
     <command>sed</command>, or <command>awk</command> use a pattern
     matching language that is similar to the one described here.
-->
<acronym>POSIX</acronym>正規表現は、パターンマッチという意味合いでは、<function>LIKE</function>および<function>SIMILAR TO</function>演算子よりもさらに強力です。
<command>egrep</command>、<command>sed</command>、あるいは<command>awk</command>のような多くのUnixツールはここで解説しているのと類似したパターンマッチ言語を使用しています。
    </para>

    <para>
<!--
     A regular expression is a character sequence that is an
     abbreviated definition of a set of strings (a <firstterm>regular
     set</firstterm>).  A string is said to match a regular expression
     if it is a member of the regular set described by the regular
     expression.  As with <function>LIKE</function>, pattern characters
     match string characters exactly unless they are special characters
     in the regular expression language &mdash; but regular expressions use
     different special characters than <function>LIKE</function> does.
     Unlike <function>LIKE</function> patterns, a
     regular expression is allowed to match anywhere within a string, unless
     the regular expression is explicitly anchored to the beginning or
     end of the string.
-->
正規表現とは文字列の集合（<firstterm>正規集合</firstterm>）の簡略された定義である文字が連なっているものです。
ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現にマッチしていると呼ばれます。
<function>LIKE</function>と同様、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全にマッチされます。とは言っても、正規表現は<function>LIKE</function>関数が使用するのとは異なる特殊文字を使用します。
<function>LIKE</function>関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定されていない限り文字列内のどの位置でもマッチを行えます。
    </para>

    <para>
<!--
     Some examples:
-->
例：
<programlisting>
'abc' ~ 'abc'    <lineannotation>true</lineannotation>
'abc' ~ '^a'     <lineannotation>true</lineannotation>
'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>
'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>
</programlisting>
    </para>

    <para>
<!--
     The <acronym>POSIX</acronym> pattern language is described in much
     greater detail below.
-->
<acronym>POSIX</acronym>パターン言語について以下により詳しく説明します。
    </para>

    <para>
<!--
     The <function>substring</function> function with two parameters,
     <function>substring(<replaceable>string</replaceable> from
     <replaceable>pattern</replaceable>)</function>, provides extraction of a
     substring
     that matches a POSIX regular expression pattern.  It returns null if
     there is no match, otherwise the portion of the text that matched the
     pattern.  But if the pattern contains any parentheses, the portion
     of the text that matched the first parenthesized subexpression (the
     one whose left parenthesis comes first) is
     returned.  You can put parentheses around the whole expression
     if you want to use parentheses within it without triggering this
     exception.  If you need parentheses in the pattern before the
     subexpression you want to extract, see the non-capturing parentheses
     described below.
-->
2つのパラメータを持つ<function>substring</function>関数、<function>substring(<parameter>string</parameter> from <replaceable>pattern</replaceable>)</function>を使用して、POSIX正規表現パターンにマッチする部分文字列を取り出すことができます。
この関数は、マッチするものがない場合にはNULLを返し、ある場合はパターンにマッチしたテキストの一部を返します。
しかし、丸括弧を持つパターンの場合、最初の丸括弧内部分正規表現（左丸括弧が最初に来るもの）にマッチするテキストの一部が返されます。
この例外を起こさずにパターン中に丸括弧を使用したいのであれば、常に正規表現全体を丸括弧で囲むことができます。
パターン内の抽出対象の部分文字列より前に丸括弧が必要な場合、後述の捕捉されない丸括弧を参照してください。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>
substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>
substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_replace</function> function provides substitution of
     new text for substrings that match POSIX regular expression patterns.
     It has the syntax
     <function>regexp_replace</function>(<replaceable>source</replaceable>,
     <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The <replaceable>source</replaceable> string is returned unchanged if
     there is no match to the <replaceable>pattern</replaceable>.  If there is a
     match, the <replaceable>source</replaceable> string is returned with the
     <replaceable>replacement</replaceable> string substituted for the matching
     substring.  The <replaceable>replacement</replaceable> string can contain
     <literal>\</literal><replaceable>n</replaceable>, where <replaceable>n</replaceable> is 1
     through 9, to indicate that the source substring matching the
     <replaceable>n</replaceable>'th parenthesized subexpression of the pattern should be
     inserted, and it can contain <literal>\&amp;</literal> to indicate that the
     substring matching the entire pattern should be inserted.  Write
     <literal>\\</literal> if you need to put a literal backslash in the replacement
     text.
     The <replaceable>flags</replaceable> parameter is an optional text
     string containing zero or more single-letter flags that change the
     function's behavior.  Flag <literal>i</literal> specifies case-insensitive
     matching, while flag <literal>g</literal> specifies replacement of each matching
     substring rather than only the first one.  Supported flags (though
     not <literal>g</literal>) are
     described in <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_replace</function>関数は、POSIX正規表現パターンにマッチする部分文字列を新規テキストと置換します。
構文は、<function>regexp_replace</function>(<replaceable>source</replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)です。
<replaceable>pattern</replaceable>にマッチしない場合は、<replaceable>source</replaceable>文字列がそのまま返されます。
マッチすると、マッチ部分文字列を<replaceable>replacement</replaceable>文字列で置換した<replaceable>source</replaceable>文字列が返されます。
<replaceable>replacement</replaceable>文字列に<literal>\</literal><replaceable>n</replaceable>（<replaceable>n</replaceable>は1から9までの数字）を入れて、パターン内の<replaceable>n</replaceable>番目の丸括弧つき部分表現にマッチする元の部分文字列を挿入することができます。
また、<literal>\&amp;</literal>を入れて、パターン全体とマッチする部分文字列を挿入することもできます。
置換テキスト内にバックスラッシュそのものを挿入する必要がある時は<literal>\\</literal>と記述します。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくはそれ以上の1文字フラグを含むオプションのテキスト文字列です。フラグ<literal>i</literal>は大文字小文字を区別しないマッチを指定する一方、フラグ<literal>g</literal>は、最初にマッチしたもののみではなく、それぞれマッチした部分文字列の置換を指定します。
有効なフラグは(<literal>g</literal>を除く)<xref linkend="posix-embedded-options-table"/>に記述されています。
    </para>

   <para>
<!--
    Some examples:
-->
    例：
<programlisting>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <lineannotation>fooXbaz</lineannotation>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <lineannotation>fooXX</lineannotation>
regexp_replace('foobarbaz', 'b(..)', 'X\1Y', 'g')
                                   <lineannotation>fooXarYXazY</lineannotation>
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_match</function> function returns a text array of
     captured substring(s) resulting from the first match of a POSIX
     regular expression pattern to a string.  It has the syntax
     <function>regexp_match</function>(<replaceable>string</replaceable>,
     <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match, the result is <literal>NULL</literal>.
     If a match is found, and the <replaceable>pattern</replaceable> contains no
     parenthesized subexpressions, then the result is a single-element text
     array containing the substring matching the whole pattern.
     If a match is found, and the <replaceable>pattern</replaceable> contains
     parenthesized subexpressions, then the result is a text array
     whose <replaceable>n</replaceable>'th element is the substring matching
     the <replaceable>n</replaceable>'th parenthesized subexpression of
     the <replaceable>pattern</replaceable> (not counting <quote>non-capturing</quote>
     parentheses; see below for details).
     The <replaceable>flags</replaceable> parameter is an optional text string
     containing zero or more single-letter flags that change the function's
     behavior.  Supported flags are described
     in <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_match</function>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された最初の部分文字列のテキスト配列を返します。
<function>regexp_match</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
マッチするものがなければ、結果は<literal>NULL</literal>となります。
マッチする部分があり、かつ<replaceable>pattern</replaceable>が丸括弧で括られた部分文字列を含まない場合、結果はパターン全体にマッチする部分文字列を含む単一要素のテキスト配列となります。
マッチする部分があり、かつ<replaceable>pattern</replaceable>が丸括弧で括られた部分文字列を含む場合、結果はテキスト配列で、その<replaceable>n</replaceable>番目の要素は<replaceable>pattern</replaceable>の<replaceable>n</replaceable>番目に丸括弧で括られた部分文字列にマッチする部分文字列となります（<quote>捕捉されない</quote>丸括弧は数えません。詳細は以下を参照してください）。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
有効なフラグは<xref linkend="posix-embedded-options-table"/>に記載されています。
    </para>

   <para>
<!--
    Some examples:
-->
例を示します。
<programlisting>
SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)
</programlisting>
<!--
    In the common case where you just want the whole matching substring
    or <literal>NULL</literal> for no match, write something like
-->
マッチするときはマッチする部分文字列全体、マッチしないときは<literal>NULL</literal>を返したいというよくあるケースは、以下のように書くことができます。
<programlisting>
SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)
</programlisting>
   </para>

    <para>
<!--
     The <function>regexp_matches</function> function returns a set of text arrays
     of captured substring(s) resulting from matching a POSIX regular
     expression pattern to a string.  It has the same syntax as
     <function>regexp_match</function>.
     This function returns no rows if there is no match, one row if there is
     a match and the <literal>g</literal> flag is not given, or <replaceable>N</replaceable>
     rows if there are <replaceable>N</replaceable> matches and the <literal>g</literal> flag
     is given.  Each returned row is a text array containing the whole
     matched substring or the substrings matching parenthesized
     subexpressions of the <replaceable>pattern</replaceable>, just as described above
     for <function>regexp_match</function>.
     <function>regexp_matches</function> accepts all the flags shown
     in <xref linkend="posix-embedded-options-table"/>, plus
     the <literal>g</literal> flag which commands it to return all matches, not
     just the first one.
-->
<function>regexp_matches</function>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された部分文字列のテキスト配列の集合を返します。
構文は<function>regexp_match</function>と同じです。
この関数は、マッチするものがないときは行を返しませんが、マッチするものがあり、<literal>g</literal>フラグが指定されていないときは1行だけ、マッチするものが<replaceable>N</replaceable>個あり、<literal>g</literal>フラグが指定されているときは<replaceable>N</replaceable>行を返します。
返される各行は上で<function>regexp_match</function>について説明したのと全く同じで、マッチする部分文字列全体、または丸括弧で括られた部分文字列にマッチする部分文字列を含むテキスト配列です。
<function>regexp_matches</function>は<xref linkend="posix-embedded-options-table"/>に示すすべてのフラグに加え、最初のマッチだけでなくすべてのマッチを返す<literal>g</literal>を受け付けます。
    </para>

   <para>
<!--
    Some examples:
-->
例を示します。
<programlisting>
SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)
</programlisting>
   </para>

   <tip>
    <para>
<!--
     In most cases <function>regexp_matches()</function> should be used with
     the <literal>g</literal> flag, since if you only want the first match, it's
     easier and more efficient to use <function>regexp_match()</function>.
     However, <function>regexp_match()</function> only exists
     in <productname>PostgreSQL</productname> version 10 and up.  When working in older
     versions, a common trick is to place a <function>regexp_matches()</function>
     call in a sub-select, for example:
-->
最初にマッチするものだけが必要なときは<function>regexp_match()</function>を使う方がより簡単で効率的ですから、<function>regexp_matches()</function>はほとんどの場合<literal>g</literal>フラグを指定して使われるでしょう。
しかし、<function>regexp_match()</function>は<productname>PostgreSQL</productname>のバージョン10以上でのみ利用できます。
古いバージョンを使う時によくある手法は、以下の例のように、副SELECTの中に<function>regexp_matches()</function>の呼び出しを入れることです。
<programlisting>
SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;
</programlisting>
<!--
     This produces a text array if there's a match, or <literal>NULL</literal> if
     not, the same as <function>regexp_match()</function> would do.  Without the
     sub-select, this query would produce no output at all for table rows
     without a match, which is typically not the desired behavior.
-->
これは<function>regexp_match()</function>と同じく、マッチするものがあればテキスト配列を生成し、マッチしなければ<literal>NULL</literal>となります。
副SELECTを使わなければ、マッチするものがないテーブル行については問い合わせの出力が生成されず、多くの場合に期待される動作と異なります。
    </para>
   </tip>

    <para>
<!--
     The <function>regexp_split_to_table</function> function splits a string using a POSIX
     regular expression pattern as a delimiter.  It has the syntax
     <function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     If there is no match to the <replaceable>pattern</replaceable>, the function returns the
     <replaceable>string</replaceable>.  If there is at least one match, for each match it returns
     the text from the end of the last match (or the beginning of the string)
     to the beginning of the match.  When there are no more matches, it
     returns the text from the end of the last match to the end of the string.
     The <replaceable>flags</replaceable> parameter is an optional text string containing
     zero or more single-letter flags that change the function's behavior.
     <function>regexp_split_to_table</function> supports the flags described in
     <xref linkend="posix-embedded-options-table"/>.
-->
<function>regexp_split_to_table</function>関数はPOSIX正規表現パターンを区切り文字として使用し、文字列を分割します。<function>regexp_split_to_table</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
<replaceable>pattern</replaceable>にマッチしない場合、関数は<replaceable>string</replaceable>を返します。
少なくともひとつのマッチがあれば、それぞれのマッチに対して関数は最後のマッチの終わり（あるいは文字列の始め）から最初のマッチまでのテキストを返します。
もはやマッチしなくなると最後のマッチの終わりから文字列の最後までテキストを返します。
<replaceable>flags</replaceable>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
<function>regexp_split_to_table</function>は<xref linkend="posix-embedded-options-table"/>で記載されているフラグをサポートします。
    </para>

    <para>
<!--
     The <function>regexp_split_to_array</function> function behaves the same as
     <function>regexp_split_to_table</function>, except that <function>regexp_split_to_array</function>
     returns its result as an array of <type>text</type>.  It has the syntax
     <function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable>
     <optional>, <replaceable>flags</replaceable> </optional>).
     The parameters are the same as for <function>regexp_split_to_table</function>.
-->
<function>regexp_split_to_array</function>関数は、<function>regexp_split_to_array</function>がその結果を<type>text</type>配列で返すことを除いて、<function>regexp_split_to_table</function>と同じ動作をします。
<function>regexp_split_to_array</function>(<replaceable>string</replaceable>, <replaceable>pattern</replaceable> <optional>, <replaceable>flags</replaceable> </optional>)の構文になります。
パラメータは<function>regexp_split_to_table</function>のものと同じです。
    </para>

   <para>
<!--
    Some examples:
-->
例：
<programlisting>

SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', '\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)
</programlisting>
   </para>

   <para>
<!--
    As the last example demonstrates, the regexp split functions ignore
    zero-length matches that occur at the start or end of the string
    or immediately after a previous match.  This is contrary to the strict
    definition of regexp matching that is implemented by
    <function>regexp_match</function> and
    <function>regexp_matches</function>, but is usually the most convenient behavior
    in practice.  Other software systems such as Perl use similar definitions.
-->
最後の例が明らかにしているように、regexp分割関数は文字列の最初あるいは終わり、もしくは前のマッチの直後に発生する長さを持たないマッチを無視します。
<function>regexp_match</function>および<function>regexp_matches</function>で実装されたregexpマッチの厳格な定義にこれは相容れませんが、実務上は最も使い勝手の良い動作です。
Perlのような他のソフトウェアシステムも似たような定義を使用します。
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
<!--
    <title>Regular Expression Details</title>
-->
    <title>正規表現の詳細</title>

   <para>
<!--
    <productname>PostgreSQL</productname>'s regular expressions are implemented
    using a software package written by Henry Spencer.  Much of
    the description of regular expressions below is copied verbatim from his
    manual.
-->
<productname>PostgreSQL</productname>の正規表現はHenry Spencerにより書かれたソフトウェアパッケージを使用して実装されています。
以下に説明する正規表現の多くの部分は同氏のマニュアルから一字一句複製したものです。
   </para>

   <para>
<!--
    Regular expressions (<acronym>RE</acronym>s), as defined in
    <acronym>POSIX</acronym> 1003.2, come in two forms:
    <firstterm>extended</firstterm> <acronym>RE</acronym>s or <acronym>ERE</acronym>s
    (roughly those of <command>egrep</command>), and
    <firstterm>basic</firstterm> <acronym>RE</acronym>s or <acronym>BRE</acronym>s
    (roughly those of <command>ed</command>).
    <productname>PostgreSQL</productname> supports both forms, and
    also implements some extensions
    that are not in the POSIX standard, but have become widely used
    due to their availability in programming languages such as Perl and Tcl.
    <acronym>RE</acronym>s using these non-POSIX extensions are called
    <firstterm>advanced</firstterm> <acronym>RE</acronym>s or <acronym>ARE</acronym>s
    in this documentation.  AREs are almost an exact superset of EREs,
    but BREs have several notational incompatibilities (as well as being
    much more limited).
    We first describe the ARE and ERE forms, noting features that apply
    only to AREs, and then describe how BREs differ.
-->
<acronym>POSIX</acronym> 1003.2の定義によると、正規表現（<acronym>RE</acronym>）には2つの形式があるとされます。<firstterm>拡張</firstterm><acronym>RE</acronym>もしくは<acronym>ERE</acronym>（大まかにいって<command>egrep</command>に代表されるもの）、および<firstterm>基本</firstterm><acronym>RE</acronym>もしくは<acronym>BRE</acronym>（大まかにいって<command>ed</command>に代表されるもの）です。
<productname>PostgreSQL</productname>は両方の形式をサポートし、さらに、POSIX標準にはないけれどもPerlやTclなどのプログラミング言語で利用できることから広く使用されるようになった、いくつかの拡張もサポートしています。
本書では、非POSIX拡張を使用した<acronym>RE</acronym>を<firstterm>高度な</firstterm><acronym>RE</acronym>もしくは<acronym>ARE</acronym>と呼びます。AREはEREの正確な上位セットですが、BREとは複数の記法上の非互換な点があります（さらに非常に多くの制限が課されています）。
まず、AREとERE形式について説明し、そして、AREにのみ適用される機能の注意を、さらにBREとの違いについて説明します。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> always initially presumes that a regular
     expression follows the ARE rules.  However, the more limited ERE or
     BRE rules can be chosen by prepending an <firstterm>embedded option</firstterm>
     to the RE pattern, as described in <xref linkend="posix-metasyntax"/>.
     This can be useful for compatibility with applications that expect
     exactly the <acronym>POSIX</acronym> 1003.2 rules.
-->
<productname>PostgreSQL</productname>は常に、まず正規表現はARE規則に従うと推測します。
しかし、REパターンの前に、<xref linkend="posix-metasyntax"/>に記載されているような<firstterm>埋め込みオプション</firstterm>を追加することにより、より限られたERE、あるいはBRE規則を選択することができます。
これは、<acronym>POSIX</acronym>1003.2の規則を正確に期待しているアプリケーションとの互換性に関して有用です。
    </para>
   </note>

   <para>
<!--
    A regular expression is defined as one or more
    <firstterm>branches</firstterm>, separated by
    <literal>|</literal>.  It matches anything that matches one of the
    branches.
-->
正規表現は<literal>|</literal>で区切られた、1つまたは複数の<firstterm>ブランチ</firstterm>として定義されます。
ブランチのいずれか1つにマッチすればマッチしたことになります。
   </para>

   <para>
<!--
    A branch is zero or more <firstterm>quantified atoms</firstterm> or
    <firstterm>constraints</firstterm>, concatenated.
    It matches a match for the first, followed by a match for the second, etc;
    an empty branch matches the empty string.
-->
ブランチはゼロ個以上の<firstterm>量化アトム</firstterm>もしくは<firstterm>制約</firstterm>の連結です。
最初のものにマッチに、次に第２番目のものにマッチを、というふうにマッチします。なお、空のブランチは空文字列にマッチします。
   </para>

   <para>
<!--
    A quantified atom is an <firstterm>atom</firstterm> possibly followed
    by a single <firstterm>quantifier</firstterm>.
    Without a quantifier, it matches a match for the atom.
    With a quantifier, it can match some number of matches of the atom.
    An <firstterm>atom</firstterm> can be any of the possibilities
    shown in <xref linkend="posix-atoms-table"/>.
    The possible quantifiers and their meanings are shown in
    <xref linkend="posix-quantifiers-table"/>.
-->
量化アトムとは、単一の<firstterm>量指定子</firstterm>が後ろに付く<firstterm>アトム</firstterm>のことです。
量指定子がないと、アトムにマッチするものがマッチしたことになります。
量指定子がある場合、アトムとのマッチが何回あるかでマッチしたことになります。
<firstterm>アトム</firstterm>は、<xref linkend="posix-atoms-table"/>に示したもののいずれかを取ることができます。
  <xref linkend="posix-quantifiers-table"/>に設定可能な量指定子とその意味を示します。
   </para>

   <para>
<!--
    A <firstterm>constraint</firstterm> matches an empty string, but matches only when
    specific conditions are met.  A constraint can be used where an atom
    could be used, except it cannot be followed by a quantifier.
    The simple constraints are shown in
    <xref linkend="posix-constraints-table"/>;
    some more constraints are described later.
-->
<firstterm>制約</firstterm>は空文字に、特定の条件に合う場合のみにマッチします。
アトムを使用できるところには制約を使用することができます。ただしその後に量指定子を付けることはできません。
単純な制約を<xref linkend="posix-constraints-table"/>に示します。後で他のいくつかの制約を説明します。
   </para>


   <table id="posix-atoms-table">
<!--
    <title>Regular Expression Atoms</title>
-->
    <title>正規表現のアトム</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Atom</entry>
       <entry>Description</entry>
-->
       <entry>アトム</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> (where <replaceable>re</replaceable> is any regular expression)
       matches a match for
       <replaceable>re</replaceable>, with the match noted for possible reporting </entry>
-->
       <entry>（ここで<replaceable>re</replaceable> は任意の正規表現で、）<replaceable>re</replaceable>とのマッチに適合するもです。 マッチは可能である報告用と意味づけられます。</entry>
       </row>

       <row>
       <entry> <literal>(?:</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> as above, but the match is not noted for reporting
       (a <quote>non-capturing</quote> set of parentheses)
       (AREs only) </entry>
-->
       <entry>上と同じ。ただし、マッチは報告用と意味づけられません。（<quote>捕捉されない</quote>括弧の集合）（AREのみ）</entry>
       </row>

       <row>
       <entry> <literal>.</literal> </entry>
<!--
       <entry> matches any single character </entry>
-->
       <entry>任意の1文字にマッチします。</entry>
       </row>

       <row>
       <entry> <literal>[</literal><replaceable>chars</replaceable><literal>]</literal> </entry>
<!--
       <entry> a <firstterm>bracket expression</firstterm>,
       matching any one of the <replaceable>chars</replaceable> (see
       <xref linkend="posix-bracket-expressions"/> for more detail) </entry>
-->
       <entry>
        <firstterm>ブラケット式</firstterm>。
        <replaceable>chars</replaceable>のいずれか1つにマッチします
       （詳細は<xref linkend="posix-bracket-expressions"/>を参照してください）。
       </entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>k</replaceable> </entry>
<!--
       <entry> (where <replaceable>k</replaceable> is a non-alphanumeric character)
       matches that character taken as an ordinary character,
       e.g., <literal>\\</literal> matches a backslash character </entry>
-->
       <entry>（ここで<replaceable>k</replaceable>は英数字以外です。）普通の文字として指定した文字にマッチします。例えば、<literal>\\</literal>はバックスラッシュ文字です。</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
<!--
       <entry> where <replaceable>c</replaceable> is alphanumeric
       (possibly followed by other characters)
       is an <firstterm>escape</firstterm>, see <xref linkend="posix-escape-sequences"/>
       (AREs only; in EREs and BREs, this matches <replaceable>c</replaceable>) </entry>
-->
       <entry>ここで<replaceable>c</replaceable>は英数字です
       （おそらく他の文字が後に続きます）。
       <firstterm>エスケープ</firstterm>です。
       <xref linkend="posix-escape-sequences"/>を参照してください
       （AREのみ、EREとBREではこれは<replaceable>c</replaceable>にマッチします）。
       </entry>
       </row>

       <row>
       <entry> <literal>{</literal> </entry>
<!--
       <entry> when followed by a character other than a digit,
       matches the left-brace character <literal>{</literal>;
       when followed by a digit, it is the beginning of a
       <replaceable>bound</replaceable> (see below) </entry>
-->
       <entry>直後に数字以外がある場合、左中括弧<literal>{</literal>にマッチします。
直後に数字が続く場合、<replaceable>bound</replaceable>（後述）の始まりです。</entry>
       </row>

       <row>
       <entry> <replaceable>x</replaceable> </entry>
<!--
       <entry> where <replaceable>x</replaceable> is a single character with no other
       significance, matches that character </entry>
-->
       <entry>ここで<replaceable>x</replaceable>は他に意味を持たない1文字です。
<replaceable>x</replaceable>にマッチします。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    An RE cannot end with a backslash (<literal>\</literal>).
-->
REはバックスラッシュ<literal>\</literal>を終端とすることはできません。
   </para>

   <note>
    <para>
<!--
     If you have <xref linkend="guc-standard-conforming-strings"/> turned off,
     any backslashes you write in literal string constants will need to be
     doubled.  See <xref linkend="sql-syntax-strings"/> for more information.
-->
もし<xref linkend="guc-standard-conforming-strings"/>パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
  詳細は<xref linkend="sql-syntax-strings"/>を参照してください。
    </para>
   </note>

   <table id="posix-quantifiers-table">
<!--
    <title>Regular Expression Quantifiers</title>
-->
    <title>正規表現量指定子</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Quantifier</entry>
       <entry>Matches</entry>
-->
       <entry>量指定子</entry>
       <entry>マッチ</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</literal> </entry>
<!--
       <entry> a sequence of 0 or more matches of the atom </entry>
-->
       <entry>アトムの0個以上複数の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>+</literal> </entry>
<!--
       <entry> a sequence of 1 or more matches of the atom </entry>
-->
       <entry>アトムの1個以上複数の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>?</literal> </entry>
<!--
       <entry> a sequence of 0 or 1 matches of the atom </entry>
-->
       <entry>アトムの0個または1個の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
<!--
       <entry> a sequence of exactly <replaceable>m</replaceable> matches of the atom </entry>
-->
       <entry>アトムの正確に<replaceable>m</replaceable>個の並びにマッチ</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
<!--
       <entry> a sequence of <replaceable>m</replaceable> or more matches of the atom </entry>
-->
       <entry>アトムの<replaceable>m</replaceable>個以上の並びにマッチ</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
<!--
       <entry> a sequence of <replaceable>m</replaceable> through <replaceable>n</replaceable>
       (inclusive) matches of the atom; <replaceable>m</replaceable> cannot exceed
       <replaceable>n</replaceable> </entry>
-->
       <entry> アトムの<replaceable>m</replaceable>個以上<replaceable>n</replaceable>以下の並びにマッチ。
<replaceable>m</replaceable>は<replaceable>n</replaceable>を超えることはできません。</entry>
       </row>

       <row>
       <entry> <literal>*?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>*</literal> </entry>
-->
       <entry><literal>*</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>+?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>+</literal> </entry>
-->
       <entry><literal>+</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>??</literal> </entry>
<!--
       <entry> non-greedy version of <literal>?</literal> </entry>
-->
       <entry><literal>?</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>}</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry> <literal>{</literal><replaceable>m</replaceable><literal>,}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,}</literal>の最短マッチを行うバージョン</entry>
       </row>

       <row>
       <entry>
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal> </entry>
<!--
       <entry> non-greedy version of <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal> </entry>
-->
       <entry><literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>の最短マッチを行うバージョン</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    The forms using <literal>{</literal><replaceable>...</replaceable><literal>}</literal>
    are known as <firstterm>bounds</firstterm>.
    The numbers <replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound are
    unsigned decimal integers with permissible values from 0 to 255 inclusive.
-->
<literal>{</literal><replaceable>...</replaceable><literal>}</literal>を使用する形式は<firstterm>バウンド</firstterm>として知られています。
バウンド内の<replaceable>m</replaceable>と<replaceable>n</replaceable>という数は符号なし10進整数であり、0以上255以下の値を取ることができます。
   </para>

    <para>
<!--
     <firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match the
     same possibilities as their corresponding normal (<firstterm>greedy</firstterm>)
     counterparts, but prefer the smallest number rather than the largest
     number of matches.
     See <xref linkend="posix-matching-rules"/> for more detail.
-->
<firstterm>最短マッチを行う</firstterm>量指定子（AREのみで使用可能）は、対応する通常の（<firstterm>欲張りの</firstterm>）ものと同じものにマッチしますが、最大のマッチではなく最小のマッチを取ります。
詳細は<xref linkend="posix-matching-rules"/>を参照してください。
   </para>

   <note>
    <para>
<!--
     A quantifier cannot immediately follow another quantifier, e.g.,
     <literal>**</literal> is invalid.
     A quantifier cannot
     begin an expression or subexpression or follow
     <literal>^</literal> or <literal>|</literal>.
-->
量指定子の直後に量指定子を続けることはできません。例えば<literal>**</literal>は無効です。
量指定子から式や副式を始めることはできず、また、<literal>^</literal>や<literal>|</literal>の直後に付けることもできません。
    </para>
   </note>

   <table id="posix-constraints-table">
<!--
    <title>Regular Expression Constraints</title>
-->
    <title>正規表現制約</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Constraint</entry>
       <entry>Description</entry>
-->
       <entry>制約</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</literal> </entry>
<!--
       <entry> matches at the beginning of the string </entry>
-->
       <entry>文字列の先頭にマッチ</entry>
       </row>

       <row>
       <entry> <literal>$</literal> </entry>
<!--
       <entry> matches at the end of the string </entry>
-->
       <entry>文字列の末尾にマッチ</entry>
       </row>

       <row>
       <entry> <literal>(?=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>positive lookahead</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行肯定検索</firstterm>は、<replaceable>re</replaceable>にマッチする部分文字列が始まる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>negative lookahead</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> begins
       (AREs only) </entry>
-->
       <entry><firstterm>先行否定検索</firstterm>は、<replaceable>re</replaceable>にマッチしない部分文字列が始まる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;=</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>positive lookbehind</firstterm> matches at any point
       where a substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
-->
       <entry> <firstterm>後方肯定検索</firstterm>は<replaceable>re</replaceable>にマッチする部分文字列が終わる任意の場所にマッチします（AREのみ）。</entry>
       </row>

       <row>
       <entry> <literal>(?&lt;!</literal><replaceable>re</replaceable><literal>)</literal> </entry>
<!--
       <entry> <firstterm>negative lookbehind</firstterm> matches at any point
       where no substring matching <replaceable>re</replaceable> ends
       (AREs only) </entry>
-->
       <entry> <firstterm>後方否定検索</firstterm><replaceable>re</replaceable>にマッチしない部分文字列が終わる任意の場所にマッチします（AREのみ）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Lookahead and lookbehind constraints cannot contain <firstterm>back
    references</firstterm> (see <xref linkend="posix-escape-sequences"/>),
    and all parentheses within them are considered non-capturing.
-->
先行検索制約および後方検索制約には<firstterm>後方参照</firstterm>（<xref linkend="posix-escape-sequences"/>を参照）を含めることはできません。また、その中の括弧は全て取り込むものではないとみなされます。
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
<!--
    <title>Bracket Expressions</title>
-->
    <title>ブラケット式</title>

   <para>
<!--
    A <firstterm>bracket expression</firstterm> is a list of
    characters enclosed in <literal>[]</literal>.  It normally matches
    any single character from the list (but see below).  If the list
    begins with <literal>^</literal>, it matches any single character
    <emphasis>not</emphasis> from the rest of the list.
    If two characters
    in the list are separated by <literal>-</literal>, this is
    shorthand for the full range of characters between those two
    (inclusive) in the collating sequence,
    e.g., <literal>[0-9]</literal> in <acronym>ASCII</acronym> matches
    any decimal digit.  It is illegal for two ranges to share an
    endpoint, e.g.,  <literal>a-c-e</literal>.  Ranges are very
    collating-sequence-dependent, so portable programs should avoid
    relying on them.
-->
<firstterm>ブラケット式</firstterm>とは、<literal>[]</literal>内の文字のリストです。
通常これはそのリスト内の任意の1文字にマッチします（しかし、以降を参照してください）。
リストが<literal>^</literal>から始まる場合、そのリストの残りには<emphasis>ない</emphasis>任意の1文字にマッチします。
リスト内の2文字が<literal>-</literal>で区切られていた場合、これは2つ（を含む）の間にある文字範囲全体を表す省略形となります。例えば、<acronym>ASCII</acronym>における<literal>[0-9]</literal>は全ての数字にマッチします。
例えば<literal>a-c-e</literal>といった、終端を共有する2つの範囲は不正です。
範囲は並びの照合順に非常に依存しています。ですので、移植予定のプログラムではこれに依存してはなりません。
   </para>

   <para>
<!--
    To include a literal <literal>]</literal> in the list, make it the
    first character (after <literal>^</literal>, if that is used).  To
    include a literal <literal>-</literal>, make it the first or last
    character, or the second endpoint of a range.  To use a literal
    <literal>-</literal> as the first endpoint of a range, enclose it
    in <literal>[.</literal> and <literal>.]</literal> to make it a
    collating element (see below).  With the exception of these characters,
    some combinations using <literal>[</literal>
    (see next paragraphs), and escapes (AREs only), all other special
    characters lose their special significance within a bracket expression.
    In particular, <literal>\</literal> is not special when following
    ERE or BRE rules, though it is special (as introducing an escape)
    in AREs.
-->
このリストに<literal>]</literal>そのものを含めるには、それを先頭文字（もしそれが使用されれば<literal>^</literal>の後）にしてください。
<literal>-</literal>そのものを含めるには、それを先頭もしくは末尾の文字とするか、範囲の2番目の終端としてください。
<literal>-</literal>を範囲の最初の終端で使用するには、<literal>[.</literal>と<literal>.]</literal>でそれを囲み、照合要素（後述）にしてください。
これら文字と、<literal>[</literal>（次段落を参照）のなんらかの組み合わせ、およびエスケープ（AREのみ）を例外として、他の全ての特殊文字はブラケット式内では特殊な意味を持ちません。
特に、<literal>\</literal>はEREとBRE規則に従う場合は特別でなくなります。しかし、AREでは（エスケープの始まりとして）特別な意味を持ちます。
   </para>

   <para>
<!--
    Within a bracket expression, a collating element (a character, a
    multiple-character sequence that collates as if it were a single
    character, or a collating-sequence name for either) enclosed in
    <literal>[.</literal> and <literal>.]</literal> stands for the
    sequence of characters of that collating element.  The sequence is
    treated as a single element of the bracket expression's list.  This
    allows a bracket
    expression containing a multiple-character collating element to
    match more than one character, e.g., if the collating sequence
    includes a <literal>ch</literal> collating element, then the RE
    <literal>[[.ch.]]*c</literal> matches the first five characters of
    <literal>chchcc</literal>.
-->
ブラケット式内に、照合要素（文字、単一文字であるかのように照合する複数文字の並び、もしくはそれぞれの照合並びの名前）が<literal>[.</literal>と<literal>.]</literal>の間にあると、その照合要素の文字の並びを意味します。
この並びはブラケット式のリストの一要素として取り扱われます。
このことにより、ブラケット式は要素を照合する複数文字を含むブラケット式を1文字以上にマッチさせることができます。例えば、照合並びが<literal>ch</literal>照合要素を含む場合、正規表現<literal>[[.ch.]]*c</literal>は<literal>chchcc</literal>という文字の最初の5文字にマッチします。
   </para>

   <note>
    <para>
<!--
     <productname>PostgreSQL</productname> currently does not support multi-character collating
     elements. This information describes possible future behavior.
-->
今のところ、<productname>PostgreSQL</productname>は複数文字照合要素をサポートしません。
この情報は将来の振舞いの可能性を説明したものです。
    </para>
   </note>

   <para>
<!--
    Within a bracket expression, a collating element enclosed in
    <literal>[=</literal> and <literal>=]</literal> is an <firstterm>equivalence
    class</firstterm>, standing for the sequences of characters of all collating
    elements equivalent to that one, including itself.  (If there are
    no other equivalent collating elements, the treatment is as if the
    enclosing delimiters were <literal>[.</literal> and
    <literal>.]</literal>.)  For example, if <literal>o</literal> and
    <literal>^</literal> are the members of an equivalence class, then
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal>, and
    <literal>[o^]</literal> are all synonymous.  An equivalence class
    cannot be an endpoint of a range.
-->
ブラケット式内の<literal>[=</literal>と<literal>=]</literal>の間に照合要素は<firstterm>同値クラス</firstterm>です。全ての照合要素の文字の並びが自身を含むものと等価であることを示します。
（他に等価な照合要素がある場合、<literal>[.</literal>と<literal>.]</literal>で囲まれたかのように扱われます。）
例えば、<literal>[[=o=]]</literal>、<literal>[[=^=]]</literal>および<literal>[o^]</literal>が全て同意語であれば、<literal>o</literal>と<literal>^</literal>は同値クラスのメンバです。
同値クラスは範囲の終端にはなりません。
   </para>

   <para>
<!--
    Within a bracket expression, the name of a character class
    enclosed in <literal>[:</literal> and <literal>:]</literal> stands
    for the list of all characters belonging to that class.  A character
    class cannot be used as an endpoint of a range.
    The <acronym>POSIX</acronym> standard defines these character class
    names:
    <literal>alnum</literal> (letters and numeric digits),
    <literal>alpha</literal> (letters),
    <literal>blank</literal> (space and tab),
    <literal>cntrl</literal> (control characters),
    <literal>digit</literal> (numeric digits),
    <literal>graph</literal> (printable characters except space),
    <literal>lower</literal> (lower-case letters),
    <literal>print</literal> (printable characters including space),
    <literal>punct</literal> (punctuation),
    <literal>space</literal> (any white space),
    <literal>upper</literal> (upper-case letters),
    and <literal>xdigit</literal> (hexadecimal digits).
    The behavior of these standard character classes is generally
    consistent across platforms for characters in the 7-bit ASCII set.
    Whether a given non-ASCII character is considered to belong to one
    of these classes depends on the <firstterm>collation</firstterm>
    that is used for the regular-expression function or operator
    (see <xref linkend="collation"/>), or by default on the
    database's <envar>LC_CTYPE</envar> locale setting (see
    <xref linkend="locale"/>).  The classification of non-ASCII
    characters can vary across platforms even in similarly-named
    locales.  (But the <literal>C</literal> locale never considers any
    non-ASCII characters to belong to any of these classes.)
    In addition to these standard character
    classes, <productname>PostgreSQL</productname> defines
    the <literal>ascii</literal> character class, which contains exactly
    the 7-bit ASCII set.
-->
ブラケット式内では、<literal>[:</literal>と<literal>:]</literal>の間にある文字クラスの名称は、そのクラスに属する全ての文字のリストを意味します。
文字クラスは範囲の終端位置としては使用できません。
<acronym>POSIX</acronym>標準は以下の文字クラス名を定義しています。
<literal>alnum</literal>（文字と数字）、<literal>alpha</literal>（文字）、<literal>blank</literal>（空白とタブ）、<literal>cntrl</literal>（制御文字）、<literal>digit</literal>（数字）、<literal>graph</literal>（空白以外の印字可能文字）、<literal>lower</literal>（小文字）、<literal>print</literal>（空白を含む印字可能文字）、<literal>punct</literal>（句読点）、<literal>space</literal>（空白）、<literal>upper</literal>（大文字）、<literal>xdigit</literal>（16進数）です。
これらの標準文字クラスの振る舞いは7-bit ASCII集合の範囲であれば一般にどのプラットフォームでも同じです。
与えられた非ASCII文字がこれらの文字クラスに属すると考えられるかどうかは、正規表現関数または演算子（<xref linkend="collation"/>参照）で使用される<firstterm>照合順</firstterm>、あるいはデフォルトとしてはデータベースの<envar>LC_CTYPE</envar>ロケール（<xref linkend="locale"/>)の設定によります。
非ASCII文字の分類は、たとえ似たような名前のロケールであってもプラットフォームによって異なることがありえます。
（ただし<literal>C</literal>ロケールでは、すべての非ASCII文字はこれらのクラスのどれにも所属しないものとされます。）
これらの標準クラスに加え、<productname>PostgreSQL</productname>では7-bit ASCII集合を正確に含む<literal>ascii</literal>文字クラスが定義されています。
   </para>

   <para>
<!--
    There are two special cases of bracket expressions:  the bracket
    expressions <literal>[[:&lt;:]]</literal> and
    <literal>[[:&gt;:]]</literal> are constraints,
    matching empty strings at the beginning
    and end of a word respectively.  A word is defined as a sequence
    of word characters that is neither preceded nor followed by word
    characters.  A word character is an <literal>alnum</literal> character (as
    defined by the <acronym>POSIX</acronym> character class described above)
    or an underscore.  This is an extension, compatible with but not
    specified by <acronym>POSIX</acronym> 1003.2, and should be used with
    caution in software intended to be portable to other systems.
    The constraint escapes described below are usually preferable; they
    are no more standard, but are easier to type.
-->
ブラケット式には2つの特殊な場合があります。<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>というブラケット式は、先頭と終端の単語がそれぞれ空文字であることにマッチする制約です。
単語は、単語文字が前後に付かない単語文字の並びとして定義されます。
単語文字とは（上述の<acronym>POSIX</acronym>文字クラスで定義されているように）1つの<literal>alnum</literal>文字またはアンダースコアです。
これは、<acronym>POSIX</acronym> 1003.2との互換性はありますが、そこでは定義されていない式です。ですので、他システムへ移植予定のソフトウェアでの使用には注意が必要です。
通常後述の制約エスケープの方がよく使われます。これはもはや標準ではありませんが、入力しやすいものです。
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
<!--
    <title>Regular Expression Escapes</title>
-->
    <title>正規表現エスケープ</title>

   <para>
<!--
    <firstterm>Escapes</firstterm> are special sequences beginning with <literal>\</literal>
    followed by an alphanumeric character. Escapes come in several varieties:
    character entry, class shorthands, constraint escapes, and back references.
    A <literal>\</literal> followed by an alphanumeric character but not constituting
    a valid escape is illegal in AREs.
    In EREs, there are no escapes: outside a bracket expression,
    a <literal>\</literal> followed by an alphanumeric character merely stands for
    that character as an ordinary character, and inside a bracket expression,
    <literal>\</literal> is an ordinary character.
    (The latter is the one actual incompatibility between EREs and AREs.)
-->
<firstterm>エスケープ</firstterm>とは、<literal>\</literal>から始まり英数字がその後に続く特殊な並びです。
エスケープには、文字エントリ、クラス省略、制約エスケープ、後方参照といった様々な変種があります。
<literal>\</literal>の後に英数字が続くけれども、有効なエスケープを構成しない並びはAREでは不正です。
EREにはエスケープはありません。ブラケット式の外側では、<literal>\</literal>の後に英数字が続く並びは単に普通の文字としてその文字を意味します。ブラケット式の内側では、<literal>\</literal>は普通の文字です。
（後者はEREとARE間の非互換性の1つです。）
   </para>

   <para>
<!--
    <firstterm>Character-entry escapes</firstterm> exist to make it easier to specify
    non-printing and other inconvenient characters in REs.  They are
    shown in <xref linkend="posix-character-entry-escapes-table"/>.
-->
<firstterm>文字エントリエスケープ</firstterm>は非印字文字やRE内でその他の不便な文字の指定を簡略化するために存在します。
これらを<xref linkend="posix-character-entry-escapes-table"/>に示します。
   </para>

   <para>
<!--
    <firstterm>Class-shorthand escapes</firstterm> provide shorthands for certain
    commonly-used character classes.  They are
    shown in <xref linkend="posix-class-shorthand-escapes-table"/>.
-->
<firstterm>クラス省略エスケープ</firstterm>は、あるよく使用される文字クラスの省略形を提供します。
これらを<xref linkend="posix-class-shorthand-escapes-table"/>に示します。
   </para>

   <para>
<!--
    A <firstterm>constraint escape</firstterm> is a constraint,
    matching the empty string if specific conditions are met,
    written as an escape.  They are
    shown in <xref linkend="posix-constraint-escapes-table"/>.
-->
<firstterm>制約エスケープ</firstterm>は、指定した条件に合う場合に空文字にマッチする制約をエスケープとして表したものです。
これらを<xref linkend="posix-constraint-escapes-table"/>に示します。
   </para>

   <para>
<!--
    A <firstterm>back reference</firstterm> (<literal>\</literal><replaceable>n</replaceable>) matches the
    same string matched by the previous parenthesized subexpression specified
    by the number <replaceable>n</replaceable>
    (see <xref linkend="posix-constraint-backref-table"/>).  For example,
    <literal>([bc])\1</literal> matches <literal>bb</literal> or <literal>cc</literal>
    but not <literal>bc</literal> or <literal>cb</literal>.
    The subexpression must entirely precede the back reference in the RE.
    Subexpressions are numbered in the order of their leading parentheses.
    Non-capturing parentheses do not define subexpressions.
-->
<firstterm>後方参照</firstterm>（<literal>\</literal><replaceable>n</replaceable>）は、直前に括弧で囲まれた副式によってマッチされた、<replaceable>n</replaceable>番目の同一文字列にマッチします（<xref linkend="posix-constraint-backref-table"/>を参照してください）。
  例えば、<literal>([bc])\1</literal>は<literal>bb</literal>もしくは<literal>cc</literal>にマッチしますが、<literal>bc</literal>や<literal>cb</literal>にはマッチしません。REでは副式全体は後方参照の前になければなりません。
副式は開括弧の順番で番号付けされます。
取り込まない括弧は副式を定義しません。
   </para>

   <table id="posix-character-entry-escapes-table">
<!--
    <title>Regular Expression Character-Entry Escapes</title>
-->
    <title>正規表現文字エントリエスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</literal> </entry>
<!--
       <entry> alert (bell) character, as in C </entry>
-->
       <entry>C言語と同じ警報（ベル）文字</entry>
       </row>

       <row>
       <entry> <literal>\b</literal> </entry>
<!--
       <entry> backspace, as in C </entry>
-->
       <entry>C言語と同じバックスペース</entry>
       </row>

       <row>
       <entry> <literal>\B</literal> </entry>
<!--
       <entry> synonym for backslash (<literal>\</literal>) to help reduce the need for backslash
       doubling </entry>
-->
       <entry> バックスラッシュの必要な二重化回数を減らすためのバックスラッシュ（<literal>\</literal>）の同義語</entry>
       </row>

       <row>
       <entry> <literal>\c</literal><replaceable>X</replaceable> </entry>
<!--
       <entry> (where <replaceable>X</replaceable> is any character) the character whose
       low-order 5 bits are the same as those of
       <replaceable>X</replaceable>, and whose other bits are all zero </entry>
-->
       <entry>（ここで<replaceable>X</replaceable>は任意の文字で）その下位5ビットが<replaceable>X</replaceable>と同一、その他のビットが0となる文字 </entry>
       </row>

       <row>
       <entry> <literal>\e</literal> </entry>
<!--
       <entry> the character whose collating-sequence name
       is <literal>ESC</literal>,
       or failing that, the character with octal value <literal>033</literal> </entry>
-->
       <entry>照合順名が<literal>ESC</literal>となる文字、それに失敗したら、<literal>033</literal>という8進数値を持つ文字。</entry>
       </row>

       <row>
       <entry> <literal>\f</literal> </entry>
<!--
       <entry> form feed, as in C </entry>
-->
       <entry>C言語と同じ改ページ</entry>
       </row>

       <row>
       <entry> <literal>\n</literal> </entry>
<!--
       <entry> newline, as in C </entry>
-->
       <entry>C言語と同じ改行</entry>
       </row>

       <row>
       <entry> <literal>\r</literal> </entry>
<!--
       <entry> carriage return, as in C </entry>
-->
       <entry>C言語と同じ復帰</entry>
       </row>

       <row>
       <entry> <literal>\t</literal> </entry>
<!--
       <entry> horizontal tab, as in C </entry>
-->
       <entry>C言語と同じ水平タブ</entry>
       </row>

       <row>
       <entry> <literal>\u</literal><replaceable>wxyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>wxyz</replaceable>
-->
       <entry>（ここで<replaceable>wxyz</replaceable>は正確に4桁の16進数で）その16進数での値が<literal>0x</literal><replaceable>wxyz</replaceable>という文字
       </entry>
       </row>

       <row>
       <entry> <literal>\U</literal><replaceable>stuvwxyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>stuvwxyz</replaceable>
-->
       <entry>（ここで<replaceable>stuvwxyz</replaceable>は正確に8桁の16進数で）その16進数での値が<literal>0x</literal><replaceable>stuvwxyz</replaceable>という文字
       </entry>
       </row>

       <row>
       <entry> <literal>\v</literal> </entry>
<!--
       <entry> vertical tab, as in C </entry>
-->
       <entry>C言語と同じ垂直タブ</entry>
       </row>

       <row>
       <entry> <literal>\x</literal><replaceable>hhh</replaceable> </entry>
<!--
       <entry> (where <replaceable>hhh</replaceable> is any sequence of hexadecimal
       digits)
       the character whose hexadecimal value is
       <literal>0x</literal><replaceable>hhh</replaceable>
       (a single character no matter how many hexadecimal digits are used)
-->
       <entry>（ここで<replaceable>hhh</replaceable>は任意の16進数の並びで）その文字の16進数値が<literal>0x</literal><replaceable>hhh</replaceable>となる文字（使用される16進数の桁数にかかわらず単一の文字）
       </entry>
       </row>

       <row>
       <entry> <literal>\0</literal> </entry>
<!--
       <entry> the character whose value is <literal>0</literal> (the null byte)</entry>
-->
       <entry>その値が<literal>0</literal>（NULLバイト）となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xy</replaceable> </entry>
<!--
       <entry> (where <replaceable>xy</replaceable> is exactly two octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xy</replaceable> </entry>
-->
       <entry>（ここで<replaceable>xy</replaceable>は正確に2桁の8進数で、<firstterm>後方参照</firstterm>ではない）その値が<literal>0</literal><replaceable>xy</replaceable>となる文字</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>xyz</replaceable> </entry>
<!--
       <entry> (where <replaceable>xyz</replaceable> is exactly three octal digits,
       and is not a <firstterm>back reference</firstterm>)
       the character whose octal value is
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
-->
       <entry>（ここで<replaceable>xyz</replaceable>は正確に3桁の8進数で、<firstterm>後方参照</firstterm>ではない）その値が<literal>0</literal><replaceable>xyz</replaceable>となる文字</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Hexadecimal digits are <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-<literal>F</literal>.
    Octal digits are <literal>0</literal>-<literal>7</literal>.
-->
16進数の桁とは<literal>0</literal>-<literal>9</literal>、<literal>a</literal>-<literal>f</literal>、<literal>A</literal>-<literal>F</literal>です。
8進数の桁とは<literal>0</literal>-<literal>7</literal>です。
   </para>

   <para>
<!--
    Numeric character-entry escapes specifying values outside the ASCII range
    (0-127) have meanings dependent on the database encoding.  When the
    encoding is UTF-8, escape values are equivalent to Unicode code points,
    for example <literal>\u1234</literal> means the character <literal>U+1234</literal>.
    For other multibyte encodings, character-entry escapes usually just
    specify the concatenation of the byte values for the character.  If the
    escape value does not correspond to any legal character in the database
    encoding, no error will be raised, but it will never match any data.
-->
ASCIIの範囲(0-127)外の値を指定した数字のエントリエスケープは、その意味がデータベースエンコーディングに依存します。
エンコーディングがUTF-8の場合、エスケープ値はユニコード符号位置に相当します。例えば、<literal>\u1234</literal>は文字<literal>U+1234</literal>を意味します。
その他のマルチバイトエンコーディングでは、文字エントリエスケープはたいてい文字のバイト値の連結を指定します。
エスケープ値がデータベースエンコーディングでのいかなる正当な文字にも対応しない場合、エラーは起こりませんが、いかなるデータにもマッチしません。
   </para>

   <para>
<!--
    The character-entry escapes are always taken as ordinary characters.
    For example, <literal>\135</literal> is <literal>]</literal> in ASCII, but
    <literal>\135</literal> does not terminate a bracket expression.
-->
この文字エントリエスケープは常に普通の文字と解釈されます。
例えば、<literal>\135</literal>はASCIIの<literal>]</literal>となり、<literal>\135</literal>はブラケット式の終端にはなりません。
   </para>

   <table id="posix-class-shorthand-escapes-table">
<!--
    <title>Regular Expression Class-Shorthand Escapes</title>
-->
    <title>正規表現クラス省略エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</literal> </entry>
       <entry> <literal>[[:digit:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\s</literal> </entry>
       <entry> <literal>[[:space:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\w</literal> </entry>
       <entry> <literal>[[:alnum:]_]</literal>
<!--
       (note underscore is included) </entry>
-->
       （アンダースコアが含まれることに注意）</entry>
       </row>

       <row>
       <entry> <literal>\D</literal> </entry>
       <entry> <literal>[^[:digit:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\S</literal> </entry>
       <entry> <literal>[^[:space:]]</literal> </entry>
       </row>

       <row>
       <entry> <literal>\W</literal> </entry>
       <entry> <literal>[^[:alnum:]_]</literal>
<!--
       (note underscore is included) </entry>
-->
       （アンダースコアが含まれることに注意）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Within bracket expressions, <literal>\d</literal>, <literal>\s</literal>,
    and <literal>\w</literal> lose their outer brackets,
    and <literal>\D</literal>, <literal>\S</literal>, and <literal>\W</literal> are illegal.
    (So, for example, <literal>[a-c\d]</literal> is equivalent to
    <literal>[a-c[:digit:]]</literal>.
    Also, <literal>[a-c\D]</literal>, which is equivalent to
    <literal>[a-c^[:digit:]]</literal>, is illegal.)
-->
ブラケット式内では、<literal>\d</literal>、<literal>\s</literal>、および<literal>\w</literal>はその外側の大括弧を失い、<literal>\D</literal>、<literal>\S</literal>および<literal>\W</literal>は不正です。
（ですから、例えば<literal>[a-c\d]</literal>は<literal>[a-c[:digit:]]</literal>と同じになります。また、<literal>[a-c\D]</literal>は<literal>[a-c^[:digit:]]</literal>と同じになり、不正です。）
   </para>

   <table id="posix-constraint-escapes-table">
<!--
    <title>Regular Expression Constraint Escapes</title>
-->
    <title>正規表現制約エスケープ</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</literal> </entry>
<!--
       <entry> matches only at the beginning of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>^</literal>) </entry>
-->
       <entry>文字列の先頭にのみマッチします（<literal>^</literal>との違いについては<xref linkend="posix-matching-rules"/>を参照してください）。</entry>
       </row>

       <row>
       <entry> <literal>\m</literal> </entry>
<!--
       <entry> matches only at the beginning of a word </entry>
-->
       <entry> 単語の先頭にのみマッチします。 </entry>
       </row>

       <row>
       <entry> <literal>\M</literal> </entry>
<!--
       <entry> matches only at the end of a word </entry>
-->
       <entry> 単語の末尾にのみマッチします。 </entry>
       </row>

       <row>
       <entry> <literal>\y</literal> </entry>
<!--
       <entry> matches only at the beginning or end of a word </entry>
-->
       <entry> 単語の先頭もしくは末尾にのみマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\Y</literal> </entry>
<!--
       <entry> matches only at a point that is not the beginning or end of a
       word </entry>
-->
       <entry>単語の先頭もしくは末尾以外の場所にのみマッチします。</entry>
       </row>

       <row>
       <entry> <literal>\Z</literal> </entry>
<!--
       <entry> matches only at the end of the string
       (see <xref linkend="posix-matching-rules"/> for how this differs from
       <literal>$</literal>) </entry>
-->
       <entry>文字列の末尾にのみマッチします（<literal>$</literal>との違いについては<xref linkend="posix-matching-rules"/>を参照してください）。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    A word is defined as in the specification of
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> above.
    Constraint escapes are illegal within bracket expressions.
-->
    単語は前述の<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>の規定通りに定義されます。ブラケット式内では制約エスケープは不正です。
   </para>

   <table id="posix-constraint-backref-table">
<!--
    <title>Regular Expression Back References</title>
-->
    <title>正規表現後方参照</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Escape</entry>
       <entry>Description</entry>
-->
       <entry>エスケープ</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</literal><replaceable>m</replaceable> </entry>
<!--
       <entry> (where <replaceable>m</replaceable> is a nonzero digit)
       a back reference to the <replaceable>m</replaceable>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</replaceable>は非ゼロの数です。）副式の<replaceable>m</replaceable>番目への後方参照</entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>mnn</replaceable> </entry>
<!--
       <entry> (where <replaceable>m</replaceable> is a nonzero digit, and
       <replaceable>nn</replaceable> is some more digits, and the decimal value
       <replaceable>mnn</replaceable> is not greater than the number of closing capturing
       parentheses seen so far)
       a back reference to the <replaceable>mnn</replaceable>'th subexpression </entry>
-->
       <entry>（ここで<replaceable>m</replaceable>は非ゼロの数です。<replaceable>nn</replaceable>でさらに桁を指定します。<replaceable>mnn</replaceable>10進数値は取り込み括弧の数よりも多くてはなりません。）副式の<replaceable>mnn</replaceable>番目への後方参照</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
<!--
     There is an inherent ambiguity between octal character-entry
     escapes and back references, which is resolved by the following heuristics,
     as hinted at above.
     A leading zero always indicates an octal escape.
     A single non-zero digit, not followed by another digit,
     is always taken as a back reference.
     A multi-digit sequence not starting with a zero is taken as a back
     reference if it comes after a suitable subexpression
     (i.e., the number is in the legal range for a back reference),
     and otherwise is taken as octal.
-->
8進数の文字エントリエスケープと後方参照の間には曖昧性があります。上でヒントとして示したようにこれは以下の発見的手法で解決されます。
先頭の0は常に8進数エスケープを示します。
その後に数字が続かない単一の非ゼロ数字は常に後方参照として解釈されます。
ゼロから始まらない複数数字の並びは、適切な副式の後にあれば（つまり、その番号が後方参照用の範囲内にあれば）後方参照として解釈されます。さもなくば、8進数として解釈されます。
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
<!--
    <title>Regular Expression Metasyntax</title>
-->
    <title>正規表現メタ構文</title>

   <para>
<!--
    In addition to the main syntax described above, there are some special
    forms and miscellaneous syntactic facilities available.
-->
上述の主構文の他に、特殊な形式や雑多な構文的な機能が使用可能です。
   </para>

   <para>
<!--
    An RE can begin with one of two special <firstterm>director</firstterm> prefixes.
    If an RE begins with <literal>***:</literal>,
    the rest of the RE is taken as an ARE.  (This normally has no effect in
    <productname>PostgreSQL</productname>, since REs are assumed to be AREs;
    but it does have an effect if ERE or BRE mode had been specified by
    the <replaceable>flags</replaceable> parameter to a regex function.)
    If an RE begins with <literal>***=</literal>,
    the rest of the RE is taken to be a literal string,
    with all characters considered ordinary characters.
-->
REは、2つの特殊な<firstterm>決定子</firstterm>前置詞のどちらかから始まります。
REが<literal>***:</literal>から始まるものであれば、REの残りはAREと解釈されます。
(<productname>PostgreSQL</productname>はREをAREとして推測するため、通常は影響を受けません。ただし、正規表現関数に対して<replaceable>flags</replaceable>パラメータを指定されたEREやBREモードでは影響を受けます。)
REが<literal>***=</literal>から始まるものであれば、REの残りは、全ての文字を普通の文字とみなしたリテラル文字列と解釈されます。
   </para>

   <para>
<!--
    An ARE can begin with <firstterm>embedded options</firstterm>:
    a sequence <literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>
    (where <replaceable>xyz</replaceable> is one or more alphabetic characters)
    specifies options affecting the rest of the RE.
    These options override any previously determined options &mdash;
    in particular, they can override the case-sensitivity behavior implied by
    a regex operator, or the <replaceable>flags</replaceable> parameter to a regex
    function.
    The available option letters are
    shown in <xref linkend="posix-embedded-options-table"/>.
    Note that these same option letters are used in the <replaceable>flags</replaceable>
    parameters of regex functions.
-->
AREは<firstterm>埋め込みオプション</firstterm>から始められます。<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal>という並びで残りのREに影響するオプションを指定します（ここで<replaceable>xyz</replaceable>は1つ以上の英字です）。
このオプションは、事前に決定されたオプションを上書きします。&mdash; 特に、正規表現演算子、もしくは正規表現関数に与えられた<replaceable>flags</replaceable>パラメータにより示される大文字小文字の区別を上書きします。
使用可能なオプション文字を<xref linkend="posix-embedded-options-table"/>に示します。
これらの同じオプション文字が、正規表現関数の<replaceable>flags</replaceable>パラメータで使用されることに注意して下さい。
   </para>

   <table id="posix-embedded-options-table">
<!--
    <title>ARE Embedded-Option Letters</title>
-->
    <title>ARE埋め込みオプション文字</title>

    <tgroup cols="2">
     <thead>
      <row>
<!--
       <entry>Option</entry>
       <entry>Description</entry>
-->
       <entry>オプション</entry>
       <entry>説明</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</literal> </entry>
<!--
       <entry> rest of RE is a BRE </entry>
-->
       <entry> 残りのREはBRE </entry>
       </row>

       <row>
       <entry> <literal>c</literal> </entry>
<!--
       <entry> case-sensitive matching (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別するマッチ（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>e</literal> </entry>
<!--
       <entry> rest of RE is an ERE </entry>
-->
       <entry> 残りのREはERE </entry>
       </row>

       <row>
       <entry> <literal>i</literal> </entry>
<!--
       <entry> case-insensitive matching (see
       <xref linkend="posix-matching-rules"/>) (overrides operator type) </entry>
-->
       <entry> 大文字小文字を区別しないマッチ（<xref linkend="posix-matching-rules"/>を参照）（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </entry>
       </row>

       <row>
       <entry> <literal>m</literal> </entry>
<!--
       <entry> historical synonym for <literal>n</literal> </entry>
-->
       <entry> <literal>n</literal>の歴史的な同義語 </entry>
       </row>

       <row>
       <entry> <literal>n</literal> </entry>
<!--
       <entry> newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 改行を区別するマッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>p</literal> </entry>
<!--
       <entry> partial newline-sensitive matching (see
       <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 部分的な改行を区別するマッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>q</literal> </entry>
<!--
       <entry> rest of RE is a literal (<quote>quoted</quote>) string, all ordinary
       characters </entry>
-->
       <entry> 残りのREはリテラル（<quote>引用符付けされた</quote>）文字列、全て普通の文字</entry>
       </row>

       <row>
       <entry> <literal>s</literal> </entry>
<!--
       <entry> non-newline-sensitive matching (default) </entry>
-->
       <entry> 改行を区別しないマッチ（デフォルト）</entry>
       </row>

       <row>
       <entry> <literal>t</literal> </entry>
<!--
       <entry> tight syntax (default; see below) </entry>
-->
       <entry> 厳しめの構文（デフォルト、後述） </entry>
       </row>

       <row>
       <entry> <literal>w</literal> </entry>
<!--
       <entry> inverse partial newline-sensitive (<quote>weird</quote>) matching
       (see <xref linkend="posix-matching-rules"/>) </entry>
-->
       <entry> 部分的な改行区別の逆（<quote>ワイアード</quote>）マッチ（<xref linkend="posix-matching-rules"/>を参照）</entry>
       </row>

       <row>
       <entry> <literal>x</literal> </entry>
<!--
       <entry> expanded syntax (see below) </entry>
-->
       <entry> 拡張構文（後述） </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
<!--
    Embedded options take effect at the <literal>)</literal> terminating the sequence.
    They can appear only at the start of an ARE (after the
    <literal>***:</literal> director if any).
-->
埋め込みオプションはその並びの終端<literal>)</literal>で有効になります。
AREの先頭（もし<literal>***:</literal>決定子があればその後）でのみ利用可能です。
   </para>

   <para>
<!--
    In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which all
    characters are significant, there is an <firstterm>expanded</firstterm> syntax,
    available by specifying the embedded <literal>x</literal> option.
    In the expanded syntax,
    white-space characters in the RE are ignored, as are
    all characters between a <literal>#</literal>
    and the following newline (or the end of the RE).  This
    permits paragraphing and commenting a complex RE.
    There are three exceptions to that basic rule:
-->
全ての文字が意味を持つ、通常の（<firstterm>厳しめの</firstterm>）RE構文に加え、<literal>x</literal>埋め込みオプションを指定することで利用できる<firstterm>拡張</firstterm>構文があります。
拡張構文では、RE内の空白文字は無視され、<literal>#</literal>とその後の改行（もしくはREの終端）の間の全ての文字も同様です。
これにより、段落付けや複雑なREのコメント付けが可能になります。
基本規則に対して3つの例外があります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       a white-space character or <literal>#</literal> preceded by <literal>\</literal> is
       retained
-->
直前に<literal>\</literal>が付いた空白文字もしくは<literal>#</literal>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space or <literal>#</literal> within a bracket expression is retained
-->
ブラケット式内の空白文字もしくは<literal>#</literal>は保持されます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       white space and comments cannot appear within multi-character symbols,
       such as <literal>(?:</literal>
-->
<literal>(?:</literal>などの複数文字シンボルでは、空白文字とコメントは不正です。
      </para>
     </listitem>
    </itemizedlist>

<!--
    For this purpose, white-space characters are blank, tab, newline, and
    any character that belongs to the <replaceable>space</replaceable> character class.
-->
ここでの空白文字とは、空白、タブ、改行、<replaceable>スペース</replaceable>文字クラスに属する文字です。
   </para>

   <para>
<!--
    Finally, in an ARE, outside bracket expressions, the sequence
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (where <replaceable>ttt</replaceable> is any text not containing a <literal>)</literal>)
    is a comment, completely ignored.
    Again, this is not allowed between the characters of
    multi-character symbols, like <literal>(?:</literal>.
    Such comments are more a historical artifact than a useful facility,
    and their use is deprecated; use the expanded syntax instead.
-->
最後に、AREのブラケット式の外側では、<literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>という並びはコメントになります（ここで<replaceable>ttt</replaceable>は<literal>)</literal>を含まない任意のテキストです）。
繰り返しになりますが、これは<literal>(?:</literal>などの複数文字シンボルの文字間では使用できません。
こうしたコメントは実用性というより歴史的所産です。そのため、この使用は勧めません。代わりに拡張構文を使用してください。
   </para>

   <para>
<!--
    <emphasis>None</emphasis> of these metasyntax extensions is available if
    an initial <literal>***=</literal> director
    has specified that the user's input be treated as a literal string
    rather than as an RE.
-->
初めに<literal>***=</literal>決定子が指定され、ユーザの入力がREではなくリテラルとして扱われる場合、これらのメタ構文拡張は使用<emphasis>できません</emphasis>。
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
<!--
    <title>Regular Expression Matching Rules</title>
-->
    <title>正規表現マッチ規則</title>

   <para>
<!--
    In the event that an RE could match more than one substring of a given
    string, the RE matches the one starting earliest in the string.
    If the RE could match more than one substring starting at that point,
    either the longest possible match or the shortest possible match will
    be taken, depending on whether the RE is <firstterm>greedy</firstterm> or
    <firstterm>non-greedy</firstterm>.
-->
REが文字列の中の1つ以上の部分文字列とマッチする場合において、REは最初にマッチが始まった部分文字列とマッチします。
その位置からまた1つ以上の部分文字列とマッチした際は、正規表現は<firstterm>最短マッチを行わない（欲張り型）</firstterm>か<firstterm>最短マッチを行う（非欲張り型）</firstterm>かによって、最長マッチもしくは最短マッチの文字列のどちらかにマッチします
   </para>

   <para>
<!--
    Whether an RE is greedy or not is determined by the following rules:
-->
REが最長マッチかどうかは以下の規則によって決まります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       Most atoms, and all constraints, have no greediness attribute (because
       they cannot match variable amounts of text anyway).
-->
ほとんどのアトムおよび全ての式は欲張り属性を持ちません（これらは変動する量のテキストにまったくマッチしないからです）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       Adding parentheses around an RE does not change its greediness.
-->
REを括弧で括ることは欲張りかどうかを変更しません。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a fixed-repetition quantifier
       (<literal>{</literal><replaceable>m</replaceable><literal>}</literal>
       or
       <literal>{</literal><replaceable>m</replaceable><literal>}?</literal>)
       has the same greediness (possibly none) as the atom itself.
-->
<literal>{</literal><replaceable>m</replaceable><literal>}</literal>もしくは<literal>{</literal><replaceable>m</replaceable><literal>}?</literal>といった固定繰り返し数の量指定子を持つ量指定付きアトムは、アトム自身と同一の欲張りさを持ちます（まったく持たない可能性もあります）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with other normal quantifiers (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is greedy (prefers longest match).
-->
他の通常の量指定子（<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</literal>、<replaceable>m</replaceable>と<replaceable>n</replaceable>が等しい場合も含みます）を持つ量指定付きアトムは欲張り型です（最長マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A quantified atom with a non-greedy quantifier (including
       <literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>
       with <replaceable>m</replaceable> equal to <replaceable>n</replaceable>)
       is non-greedy (prefers shortest match).
-->
他の非欲張り型量指定子（<literal>{</literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</replaceable><literal>}?</literal>、<replaceable>m</replaceable>と<replaceable>n</replaceable>が等しい場合も含みます）を持つ量指定付きアトムは非欲張り型です（最短マッチを使用します）。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       A branch &mdash; that is, an RE that has no top-level
       <literal>|</literal> operator &mdash; has the same greediness as the first
       quantified atom in it that has a greediness attribute.
-->
最上位レベルの<literal>|</literal>演算子を持たないREであるブランチは、最初の欲張り属性を持つ量指定付きアトムと同一の欲張り属性を持ちます。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       An RE consisting of two or more branches connected by the
       <literal>|</literal> operator is always greedy.
-->
<literal>|</literal>演算子で接続された2つ以上のブランチからなるREは常に欲張り型です。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
<!--
    The above rules associate greediness attributes not only with individual
    quantified atoms, but with branches and entire REs that contain quantified
    atoms.  What that means is that the matching is done in such a way that
    the branch, or whole RE, matches the longest or shortest possible
    substring <emphasis>as a whole</emphasis>.  Once the length of the entire match
    is determined, the part of it that matches any particular subexpression
    is determined on the basis of the greediness attribute of that
    subexpression, with subexpressions starting earlier in the RE taking
    priority over ones starting later.
-->
上の規則は、個々の量指定付きアトムだけではなく、量指定付きアトムを複数含むブランチやRE全体の欲張り属性に関連します。
つまり、ブランチやRE全体が<emphasis>全体として</emphasis>最長または最短の部分文字列にマッチするという方法でマッチ処理が行われます。
全体のマッチの長さが決まると、特定の部分式にマッチする部分がその部分式の欲張り属性によって決まります。この時、RE内でより前にある部分式が後にある部分式よりも高い優先度を持ちます。
   </para>

   <para>
<!--
    An example of what this means:
-->
この意味の例を示します。
<screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>123</computeroutput>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>
</screen>
<!--
    In the first case, the RE as a whole is greedy because <literal>Y*</literal>
    is greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the longest possible string starting there, i.e., <literal>Y123</literal>.
    The output is the parenthesized part of that, or <literal>123</literal>.
    In the second case, the RE as a whole is non-greedy because <literal>Y*?</literal>
    is non-greedy.  It can match beginning at the <literal>Y</literal>, and it matches
    the shortest possible string starting there, i.e., <literal>Y1</literal>.
    The subexpression <literal>[0-9]{1,3}</literal> is greedy but it cannot change
    the decision as to the overall match length; so it is forced to match
    just <literal>1</literal>.
-->
最初の例では、<literal>Y*</literal>が欲張り型であるため、REは全体として欲張り型です。
マッチは<literal>Y</literal>の位置から始まり、そこから可能な限り最長の文字列にマッチします。つまり<literal>Y123</literal>となります。
出力は括弧で括られた部分、つまり<literal>123</literal>となります。
2番目の例では、<literal>Y*?</literal>が非欲張り型のため、REは全体として非欲張り型です。
マッチは<literal>Y</literal>の位置から始まり、そこから可能な限り最短の文字列にマッチします。つまり<literal>Y1</literal>となります。
部分式<literal>[0-9]{1,3}</literal>は欲張り型ですが、決定されたマッチする全体の長さを変更することはできません。したがって、強制的に<literal>1</literal>にマッチすることになります。
   </para>

   <para>
<!--
    In short, when an RE contains both greedy and non-greedy subexpressions,
    the total match length is either as long as possible or as short as
    possible, according to the attribute assigned to the whole RE.  The
    attributes assigned to the subexpressions only affect how much of that
    match they are allowed to <quote>eat</quote> relative to each other.
-->
まとめると、REが欲張り型部分式と非欲張り型部分式の両方を持つ場合、全体のマッチ長はRE全体に割り当てられる属性に応じて、最長マッチ長か最短マッチ長のどちらかになります。
部分式に割り当てられた属性は、部分式の中でどれだけの量をその部分式の中で<quote>消費</quote>できるかのみに影響します。
   </para>

   <para>
<!--
    The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal>
    can be used to force greediness or non-greediness, respectively,
    on a subexpression or a whole RE.
    This is useful when you need the whole RE to have a greediness attribute
    different from what's deduced from its elements.  As an example,
    suppose that we are trying to separate a string containing some digits
    into the digits and the parts before and after them.  We might try to
    do that like this:
-->
<literal>{1,1}</literal>および<literal>{1,1}?</literal>量指定子を副式もしくはRE全体に使用して、それぞれ、欲張りか欲張りでないかを強制することが可能です。
RE全体に対してはその要素から推論されるものと異なる欲張りさの属性が必要な場合に、これは便利です。
例として、数字をいくつか含む文字列を数字とその前後の部分に分けようとしているとします。
次のようにしてみるかもしれません。
<screen>
SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</computeroutput>
</screen>
<!--
    That didn't work: the first <literal>.*</literal> is greedy so
    it <quote>eats</quote> as much as it can, leaving the <literal>\d+</literal> to
    match at the last possible place, the last digit.  We might try to fix
    that by making it non-greedy:
-->
上手くいきませんでした。最初の<literal>.*</literal>が欲張りで、可能なだけ<quote>消費</quote>してしまい、<literal>\d+</literal>は最後の可能な場所で最後の数字にマッチします。
欲張りでなくすることで直そうとするかもしれません。
<screen>
SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<lineannotation>Result: </lineannotation><computeroutput>{abc,0,""}</computeroutput>
</screen>
<!--
    That didn't work either, because now the RE as a whole is non-greedy
    and so it ends the overall match as soon as possible.  We can get what
    we want by forcing the RE as a whole to be greedy:
-->
またもや上手くいきませんでした。今度は、REが全体として欲張りでなくなってしまい、できる限り早く全体に渡るマッチを終わらせてしまうからです。
RE全体として欲張りにすることで欲しいものが得られます。
<screen>
SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</computeroutput>
</screen>
<!--
    Controlling the RE's overall greediness separately from its components'
    greediness allows great flexibility in handling variable-length patterns.
-->
REの全体に渡る欲張りさをその要素の欲張りさと別に制御すれば、可変長のパターンを非常に柔軟に扱えます。
   </para>

   <para>
<!--
    When deciding what is a longer or shorter match,
    match lengths are measured in characters, not collating elements.
    An empty string is considered longer than no match at all.
    For example:
    <literal>bb*</literal>
    matches the three middle characters of <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    matches all ten characters of <literal>weeknights</literal>;
    when <literal>(.*).*</literal>
    is matched against <literal>abc</literal> the parenthesized subexpression
    matches all three characters; and when
    <literal>(a*)*</literal> is matched against <literal>bc</literal>
    both the whole RE and the parenthesized
    subexpression match an empty string.
-->
マッチが長いか短いかを判断する時には、マッチの長さは照合要素ではなく文字列で測られます。
空文字列はまったくマッチする要素がない文字列よりも長いと考えられます。
例えば、<literal>bb*</literal>は<literal>abbbc</literal>の真中の3文字とマッチし、<literal>(week|wee)(night|knights)</literal>は<literal>weeknights</literal>の全ての10文字とマッチし、<literal>abc</literal>に対して<literal>(.*).*</literal>がマッチされると、括弧内の部分正規表現は3つの文字全てにマッチし、<literal>bc</literal>に対して<literal>(a*)*</literal>がマッチされると、全体のREと括弧内の正規表現は空文字列にマッチします。
   </para>

   <para>
<!--
    If case-independent matching is specified,
    the effect is much as if all case distinctions had vanished from the
    alphabet.
    When an alphabetic that exists in multiple cases appears as an
    ordinary character outside a bracket expression, it is effectively
    transformed into a bracket expression containing both cases,
    e.g., <literal>x</literal> becomes <literal>[xX]</literal>.
    When it appears inside a bracket expression, all case counterparts
    of it are added to the bracket expression, e.g.,
    <literal>[x]</literal> becomes <literal>[xX]</literal>
    and <literal>[^x]</literal> becomes <literal>[^xX]</literal>.
-->
もし大文字小文字を区別しないマッチが指定されると、アルファベット文字の大文字小文字の区別がまったくなくなったのと同じ効果を与えます。
ブラケット式の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、例えば、<literal>x</literal>が<literal>[xX]</literal>となるように大文字小文字ともにブラケット式に実質的に転換されます。
ブラケット式の中に現れた時は、（例えば）<literal>[x]</literal>が<literal>[xX]</literal>となり、また<literal>[^x]</literal>が<literal>[^xX]</literal>となるように、全ての大文字小文字それぞれの対がブラケット式に追加されます。
   </para>

   <para>
<!--
    If newline-sensitive matching is specified, <literal>.</literal>
    and bracket expressions using <literal>^</literal>
    will never match the newline character
    (so that matches will never cross newlines unless the RE
    explicitly arranges it)
    and <literal>^</literal> and <literal>$</literal>
    will match the empty string after and before a newline
    respectively, in addition to matching at beginning and end of string
    respectively.
    But the ARE escapes <literal>\A</literal> and <literal>\Z</literal>
    continue to match beginning or end of string <emphasis>only</emphasis>.
-->
改行を区別するマッチが指定されると、<literal>.</literal>と<literal>^</literal>を使用するブラケット式は（REが明示的に調整されていたとしてもマッチが改行をまたがらないようにするために）改行文字にマッチしなくなります。また、<literal>^</literal>と<literal>$</literal>はそれぞれ改行直後と直前の空文字列にマッチし、さらに、それぞれ文字列の先頭と末尾にマッチします。
しかし、AREエスケープの<literal>\A</literal>と<literal>\Z</literal>は、継続して、文字列の先頭と末尾<emphasis>のみ</emphasis>にマッチします。
   </para>

   <para>
<!--
    If partial newline-sensitive matching is specified,
    this affects <literal>.</literal> and bracket expressions
    as with newline-sensitive matching, but not <literal>^</literal>
    and <literal>$</literal>.
-->
部分的に改行を区別するマッチが指定されると、<literal>.</literal>とブラケット式は改行を区別するマッチを行うようになりますが、<literal>^</literal>と<literal>$</literal>は変更されません。
   </para>

   <para>
<!--
    If inverse partial newline-sensitive matching is specified,
    this affects <literal>^</literal> and <literal>$</literal>
    as with newline-sensitive matching, but not <literal>.</literal>
    and bracket expressions.
    This isn't very useful but is provided for symmetry.
-->
部分的に改行を区別する逆マッチが指定されると、<literal>^</literal>と<literal>$</literal>は改行を区別するマッチを行うようになりますが、<literal>.</literal>とブラケット式は変更されません。
これはあまり有用ではありません。対称性のために提供されています。
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
<!--
    <title>Limits and Compatibility</title>
-->
    <title>制限と互換性</title>

   <para>
<!--
    No particular limit is imposed on the length of REs in this
    implementation.  However,
    programs intended to be highly portable should not employ REs longer
    than 256 bytes,
    as a POSIX-compliant implementation can refuse to accept such REs.
-->
本実装ではREの長さに関する制限はありません。
しかし、移植性を高めたいプログラムでは、256バイトを超えるREを使用すべきではありません。POSIX互換の実装ではそうしたREでは混乱する可能性があります。
   </para>

   <para>
<!--
    The only feature of AREs that is actually incompatible with
    POSIX EREs is that <literal>\</literal> does not lose its special
    significance inside bracket expressions.
    All other ARE features use syntax which is illegal or has
    undefined or unspecified effects in POSIX EREs;
    the <literal>***</literal> syntax of directors likewise is outside the POSIX
    syntax for both BREs and EREs.
-->
AREの機能のうち、POSIX EREと実質的な非互換性があるのは、<literal>\</literal>がブラケット式の内側で特殊な意味を失わないという点のみです。
他の全てのARE機能は、POSIX EREでは不正、未定義、未指定な効果となる構文を使用しています。決定子の<literal>***</literal>構文などはBREおよびEREのPOSIX構文にはありません。
   </para>

   <para>
<!--
    Many of the ARE extensions are borrowed from Perl, but some have
    been changed to clean them up, and a few Perl extensions are not present.
    Incompatibilities of note include <literal>\b</literal>, <literal>\B</literal>,
    the lack of special treatment for a trailing newline,
    the addition of complemented bracket expressions to the things
    affected by newline-sensitive matching,
    the restrictions on parentheses and back references in lookahead/lookbehind
    constraints, and the longest/shortest-match (rather than first-match)
    matching semantics.
-->
多くのARE拡張はPerlから拝借したものです。
しかし、いくつかは整理され、Perlの拡張のいくつかは存在しません。
注意すべき非互換性には、<literal>\b</literal>、<literal>\B</literal>、改行の取り扱いに関する特殊な措置の欠落、改行を区別するマッチに影響する点について補足したブラケット式の追加、括弧と先行・後方検索制約内の後方参照についての制限、最長/最短（最初にマッチするではなく）マッチのセマンティクスがあります。
   </para>

   <para>
<!--
    Two significant incompatibilities exist between AREs and the ERE syntax
    recognized by pre-7.4 releases of <productname>PostgreSQL</productname>:
-->
<productname>PostgreSQL</productname>リリース7.4より前で認知された、AREとERE構文間で大きな非互換が2つあります。

    <itemizedlist>
     <listitem>
      <para>
<!--
       In AREs, <literal>\</literal> followed by an alphanumeric character is either
       an escape or an error, while in previous releases, it was just another
       way of writing the alphanumeric.
       This should not be much of a problem because there was no reason to
       write such a sequence in earlier releases.
-->
AREでは、<literal>\</literal>の後に英数字が続くものはエスケープもしくはエラーとなります。以前のリリースでは、これは単に、英数字を記述する他の方法でした。
これは、大きな問題にはならないはずです。以前のリリースではこうした並びを記述する理由がないからです。
      </para>
     </listitem>
     <listitem>
      <para>
<!--
       In AREs, <literal>\</literal> remains a special character within
       <literal>[]</literal>, so a literal <literal>\</literal> within a bracket
       expression must be written <literal>\\</literal>.
-->
AREでは、<literal>\</literal>は<literal>[]</literal>内でも特別な文字です。したがって、ブラケット式では<literal>\</literal>を<literal>\\</literal>と記述しなければなりません。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
<!--
    <title>Basic Regular Expressions</title>
-->
    <title>基本正規表現</title>

   <para>
<!--
    BREs differ from EREs in several respects.
    In BREs, <literal>|</literal>, <literal>+</literal>, and <literal>?</literal>
    are ordinary characters and there is no equivalent
    for their functionality.
    The delimiters for bounds are
    <literal>\{</literal> and <literal>\}</literal>,
    with <literal>{</literal> and <literal>}</literal>
    by themselves ordinary characters.
    The parentheses for nested subexpressions are
    <literal>\(</literal> and <literal>\)</literal>,
    with <literal>(</literal> and <literal>)</literal> by themselves ordinary characters.
    <literal>^</literal> is an ordinary character except at the beginning of the
    RE or the beginning of a parenthesized subexpression,
    <literal>$</literal> is an ordinary character except at the end of the
    RE or the end of a parenthesized subexpression,
    and <literal>*</literal> is an ordinary character if it appears at the beginning
    of the RE or the beginning of a parenthesized subexpression
    (after a possible leading <literal>^</literal>).
    Finally, single-digit back references are available, and
    <literal>\&lt;</literal> and <literal>\&gt;</literal>
    are synonyms for
    <literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal>
    respectively; no other escapes are available in BREs.
-->
BREはEREといくつかの面において異なります。
BREにおいては、<literal>|</literal>、<literal>+</literal>、<literal>?</literal>は普通の文字であり、それらの機能と等価なものはありません。
バウンドの区切りは<literal>\{</literal>と<literal>\}</literal>であり、<literal>{</literal>と<literal>}</literal>自身は普通の文字です。
副式を入れ子にするための括弧は<literal>\(</literal>と<literal>\)</literal>であり、<literal>(</literal>と<literal>)</literal>自身は普通の文字です。
<literal>^</literal>は、REの先頭にある場合や括弧内の副式の先頭の場合を除き、普通の文字です。
<literal>$</literal>は、REの末尾にある場合や括弧内の副式の末尾の場合を除き、普通の文字です。
また、<literal>*</literal>はREの先頭にある場合や括弧内の副式の先頭にある場合には普通の文字になります（その前に<literal>^</literal>が付いている可能性もあります）。
最後に、1桁の後方参照を使用することができ、また、BREにおいては、<literal>\&lt;</literal>と<literal>\&gt;</literal>はそれぞれ<literal>[[:&lt;:]]</literal>と<literal>[[:&gt;:]]</literal>と同義です。
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

   <sect3 id="posix-vs-xquery">
<!--
   <title>Differences From XQuery (<literal>LIKE_REGEX</literal>)</title>
-->
   <title>XQueryとの違い(<literal>LIKE_REGEX</literal>)</title>

   <indexterm zone="posix-vs-xquery">
    <primary><literal>LIKE_REGEX</literal></primary>
   </indexterm>

   <indexterm zone="posix-vs-xquery">
<!--
    <primary>XQuery regular expressions</primary>
-->
    <primary>XQuery正規表現</primary>
   </indexterm>

    <para>
<!--
     Since SQL:2008, the SQL standard includes
     a <literal>LIKE_REGEX</literal> operator that performs pattern
     matching according to the XQuery regular expression
     standard.  <productname>PostgreSQL</productname> does not yet
     implement this operator, but you can get very similar behavior using
     the <function>regexp_match()</function> function, since XQuery
     regular expressions are quite close to the ARE syntax described above.
-->
SQL:2008以降、SQL標準にはXQuery正規表現標準によるパターンマッチングを行う<literal>LIKE_REGEX</literal>演算子が含まれています。
<productname>PostgreSQL</productname>は今の所この演算子を実装していませんが、<function>regexp_match()</function>を使ってよく似た振る舞いを得ることができます。
XQueryの正規表現は上で述べたARE構文に非常に近いからです。
    </para>

    <para>
<!--
     Notable differences between the existing POSIX-based
     regular-expression feature and XQuery regular expressions include:
-->
既存のPOSIXベースの正規表現機能とXQueryの正規表現の主な違いには以下のものが含まれます。

     <itemizedlist>
      <listitem>
       <para>
<!--
        XQuery character class subtraction is not supported.  An example of
        this feature is using the following to match only English
        consonants: <literal>[a-z-[aeiou]]</literal>.
-->
XQueryの文字クラス減算はサポートされていません。
この機能の例としては、<literal>[a-z-[aeiou]]</literal>のようにして英語の子音のみにマッチさせるというのがあります。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery character class shorthands <literal>\c</literal>,
        <literal>\C</literal>, <literal>\i</literal>,
        and <literal>\I</literal> are not supported.
-->
XQueryの文字クラス短縮形<literal>\c</literal>、<literal>\C</literal>、<literal>\i</literal>、<literal>\I</literal>はサポートされていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery character class elements
        using <literal>\p{UnicodeProperty}</literal> or the
        inverse <literal>\P{UnicodeProperty}</literal> are not supported.
-->
<literal>\p{UnicodeProperty}</literal>あるいはその逆である<literal>\P{UnicodeProperty}</literal>を使ったXQueryの文字クラス要素はサポートされていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        POSIX interprets character classes such as <literal>\w</literal>
        (see <xref linkend="posix-class-shorthand-escapes-table"/>)
        according to the prevailing locale (which you can control by
        attaching a <literal>COLLATE</literal> clause to the operator or
        function).  XQuery specifies these classes by reference to Unicode
        character properties, so equivalent behavior is obtained only with
        a locale that follows the Unicode rules.
-->
POSIXは有効なロケール（演算子あるいは関数の<literal>COLLATE</literal>節で制御できます）にしたがい、<literal>\w</literal>（<xref linkend="posix-class-shorthand-escapes-table"/>参照）のような文字クラスを解釈します。
XQueryはこれらのクラスをUnicodeの文字属性を参照してこれらのクラスを決定します。
ですからUnicodeルールに従うロケールを使用してのみ同等の振る舞いを得ることができます。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The SQL standard (not XQuery itself) attempts to cater for more
        variants of <quote>newline</quote> than POSIX does.  The
        newline-sensitive matching options described above consider only
        ASCII NL (<literal>\n</literal>) to be a newline, but SQL would have
        us treat CR (<literal>\r</literal>), CRLF (<literal>\r\n</literal>)
        (a Windows-style newline), and some Unicode-only characters like
        LINE SEPARATOR (U+2028) as newlines as well.
        Notably, <literal>.</literal> and <literal>\s</literal> should
        count <literal>\r\n</literal> as one character not two according to
        SQL.
-->
SQL標準（XQuery自身ではなく）はPOSIXが提供するより多様な<quote>newline</quote>の亜種を提供しようとしています。
上で述べた改行に敏感なマッチオプションはASCII NL（<literal>\n</literal>）だけを改行として考慮します。
しかしSQLはCR （<literal>\r</literal>）、CRLF （<literal>\r\n</literal>）(Windowsスタイルの改行）、LINE SEPARATOR (U+2028)のようなUnicodeのみの文字も改行として扱うことを求めています。
とりわけ、SQLにおいては、<literal>.</literal>と<literal>\s</literal>は<literal>\r\n</literal>を2文字ではなく、1文字として数える必要があります。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        Of the character-entry escapes described in
        <xref linkend="posix-character-entry-escapes-table"/>,
        XQuery supports only <literal>\n</literal>, <literal>\r</literal>,
        and <literal>\t</literal>.
-->
<xref linkend="posix-character-entry-escapes-table"/>で示す文字エントリエスケープのうち、XQueryは<literal>\n</literal>、<literal>\r</literal>、<literal>\t</literal>だけをサポートしています。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery does not support
        the <literal>[:<replaceable>name</replaceable>:]</literal> syntax
        for character classes within bracket expressions.
-->
XQueryはブラケット式内の文字クラスとして<literal>[:<replaceable>name</replaceable>:]</literal>構文をサポートしていません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        XQuery does not have lookahead or lookbehind constraints,
        nor any of the constraint escapes described in
        <xref linkend="posix-constraint-escapes-table"/>.
-->
XQueryには先行検索制約および後方検索制約がありませんし、<xref linkend="posix-constraint-escapes-table"/>に記述された制約エスケープもありません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The metasyntax forms described in <xref linkend="posix-metasyntax"/>
        do not exist in XQuery.
-->
<xref linkend="posix-metasyntax"/>に記述されたメタ構文形式はXQueryには存在しません。
       </para>
      </listitem>
      <listitem>
       <para>
<!--
        The regular expression flag letters defined by XQuery are
        related to but not the same as the option letters for POSIX
        (<xref linkend="posix-embedded-options-table"/>).  While the
        <literal>i</literal> and <literal>q</literal> options behave the
        same, others do not:
-->
XQueryで定義された正規表現フラグ文字はPOSIX（<xref linkend="posix-embedded-options-table"/>）のオプション文字に関連していますが、同じではありません。
<literal>i</literal>と<literal>q</literal>オプションは同じように振る舞いますが、その他は違います。
        <itemizedlist>
         <listitem>
          <para>
<!--
           XQuery's <literal>s</literal> (allow dot to match newline)
           and <literal>m</literal> (allow <literal>^</literal>
           and <literal>$</literal> to match at newlines) flags provide
           access to the same behaviors as
           POSIX's <literal>n</literal>, <literal>p</literal>
           and <literal>w</literal> flags, but they
           do <emphasis>not</emphasis> match the behavior of
           POSIX's <literal>s</literal> and <literal>m</literal> flags.
           Note in particular that dot-matches-newline is the default
           behavior in POSIX but not XQuery.
-->
XQueryの<literal>s</literal>（ピリオドが改行にマッチすることを許容する）と<literal>m</literal>（<literal>^</literal>と<literal>$</literal>が改行位置でマッチすることを許容する）フラグは、POSIXの<literal>n</literal>、<literal>p</literal>、<literal>w</literal>フラグと同じ挙動を提供しますが、POSIXの<literal>s</literal>と<literal>m</literal>フラグの挙動とは一致<emphasis>しません</emphasis>。
ピリオドが改行にマッチするのはPOSIXではデフォルトの挙動ですが、XQueryではそうでないことに留意してください。
          </para>
         </listitem>
         <listitem>
          <para>
<!--
           XQuery's <literal>x</literal> (ignore whitespace in pattern) flag
           is noticeably different from POSIX's expanded-mode flag.
           POSIX's <literal>x</literal> flag also
           allows <literal>#</literal> to begin a comment in the pattern,
           and POSIX will not ignore a whitespace character after a
           backslash.
-->
XQueryの<literal>x</literal>（パターン中の空白を無視する）フラグはPOSIXの拡張モードフラグとは著しく異なります。
POSIXの<literal>x</literal>フラグは<literal>#</literal>でパターン中のコメントを始めることもできます。
POSIXはバックスラッシュ以降の空白文字を無視しません。
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>

   </sect3>
  </sect2>
 </sect1>

<!-- split-func1-end -->
