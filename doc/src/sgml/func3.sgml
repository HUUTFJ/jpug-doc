<!-- 警告：このファイルは直接編集しないでください！
1. func.sgmlを編集したら、split.shを起動します。
2. するとfunc[0-4].sgmlが生成されます。
3. func.sgmlとともにfunc[0-4].sgmlのうち変更されたファイルをcommit/pushしてpull requestを作成してください。
4. レビューはfunc[0-4].sgmlに対して行います。
5. 指摘された点があればfunc.sgmlに反映し、1に戻ります。
6. func.sgmlの変更がなければ、pull requestをマージして終了です。お疲れ様でした！
-->
<!-- split-func3-start -->
 <sect1 id="functions-json">
  <title>JSON Functions and Operators</title>

  <indexterm zone="functions-json">
   <primary>JSON</primary>
   <secondary>functions and operators</secondary>
  </indexterm>

  <para>
   This section describes:

   <itemizedlist>
    <listitem>
     <para>
      functions and operators for processing and creating JSON data
     </para>
    </listitem>
    <listitem>
     <para>
      the SQL/JSON path language
     </para>
    </listitem>
   </itemizedlist>
  </para>

  <para>
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
  </para>

  <sect2 id="functions-json-processing">
   <title>Processing and Creating JSON Data</title>

  <para>
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
   In addition, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, though not for <type>json</type>.  The comparison
   operators follow the ordering rules for B-tree operations outlined in
   <xref linkend="json-indexing"/>.
  </para>

  <table id="functions-json-op-table">
    <title><type>json</type> and <type>jsonb</type> Operators</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array
        (array elements are indexed from zero, but negative integers count
        from the end).
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</literal>
        <returnvalue>{"c":"baz"}</returnvalue>
       </para>
       <para>
        <literal>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</literal>
        <returnvalue>{"a":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key.
       </para>
       <para>
        <literal>'{"a": {"b":"foo"}}'::json -&gt; 'a'</literal>
        <returnvalue>{"b":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>integer</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts <parameter>n</parameter>'th element of JSON array,
        as <type>text</type>.
       </para>
       <para>
        <literal>'[1,2,3]'::json -&gt;&gt; 2</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>-&gt;&gt;</literal> <type>text</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON object field with the given key, as <type>text</type>.
       </para>
       <para>
        <literal>'{"a":1,"b":2}'::json -&gt;&gt; 'b'</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path, where path elements
        can be either field keys or array indexes.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</literal>
        <returnvalue>"bar"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>json</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <type>jsonb</type> <literal>#&gt;&gt;</literal> <type>text[]</type>
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
       </para>
       <para>
        <literal>'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</literal>
        <returnvalue>bar</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such key or array element exists.
   </para>
  </note>

  <para>
   Some further operators exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively search indexed
   <type>jsonb</type> data.
  </para>

  <table id="functions-jsonb-op-table">
    <title>Additional <type>jsonb</type> Operators</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@&gt;</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first JSON value contain the second?
        (See <xref linkend="json-containment"/> for details about containment.)
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb &#64;&gt; '{"b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>&lt;@</literal> <type>jsonb</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first JSON value contained in the second?
       </para>
       <para>
        <literal>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?</literal> <type>text</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the text string exist as a top-level key or array element within
        the JSON value?
       </para>
       <para>
        <literal>'{"a":1, "b":2}'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ? 'b'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?|</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do any of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>?&amp;</literal> <type>text[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do all of the strings in the text array exist as top-level keys or
        array elements?
       </para>
       <para>
        <literal>'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>||</literal> <type>jsonb</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Concatenates two <type>jsonb</type> values.
        Concatenating two objects generates an object with the union of their
        keys, taking the second object's value when there are duplicate keys.
        Does not operate recursively: only the top-level array or object
        structure is merged.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</literal>
        <returnvalue>["a", "b", "a", "d"]</returnvalue>
       </para>
       <para>
        <literal>'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</literal>
        <returnvalue>{"a": "b", "c": "d"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes a key (and its value) from a JSON object, or matching string
        value(s) from a JSON array.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - 'a'</literal>
        <returnvalue>{"c": "d"}</returnvalue>
       </para>
       <para>
        <literal>'["a", "b", "c", "b"]'::jsonb - 'b'</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all matching keys or array elements from the left operand.
       </para>
       <para>
        <literal>'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</literal>
        <returnvalue>{}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>-</literal> <type>integer</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the array element with specified index (negative
        integers count from the end).  Throws an error if JSON value
        is not an array.
       </para>
       <para>
        <literal>'["a", "b"]'::jsonb - 1 </literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>#-</literal> <type>text[]</type>
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes the field or array element at the specified path, where path
        elements can be either field keys or array indexes.
       </para>
       <para>
        <literal>'["a", {"b":1}]'::jsonb #- '{1,b}'</literal>
        <returnvalue>["a", {}]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@?</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does JSON path return any item for the specified JSON value?
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ > 2)'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>jsonb</type> <literal>@@</literal> <type>jsonpath</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the
        specified JSON value.  Only the first item of the result is taken into
        account.  If the result is not Boolean, then <literal>NULL</literal>
        is returned.
       </para>
       <para>
        <literal>'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] > 2'</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
   <para>
    The <type>jsonpath</type> operators <literal>@?</literal>
    and <literal>@@</literal> suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The <type>jsonpath</type>-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
   </para>
  </note>

  <para>
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for constructing <type>json</type> and <type>jsonb</type> values.
  </para>

  <table id="functions-json-creation-table">
    <title>JSON Creation Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>to_json</primary>
        </indexterm>
        <function>to_json</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>to_jsonb</primary>
        </indexterm>
        <function>to_jsonb</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Converts any SQL value to <type>json</type> or <type>jsonb</type>.
        Arrays and composites are converted recursively to arrays and
        objects (multidimensional arrays become arrays of arrays in JSON).
        Otherwise, if there is a cast from the SQL data type
        to <type>json</type>, the cast function will be used to perform the
        conversion;<footnote>
         <para>
          For example, the <xref linkend="hstore"/> extension has a cast
          from <type>hstore</type> to <type>json</type>, so that
          <type>hstore</type> values converted via the JSON creation functions
          will be represented as JSON objects, not as primitive string values.
         </para>
        </footnote>
        otherwise, a scalar JSON value is produced.  For any scalar other than
        a number, a Boolean, or a null value, the text representation will be
        used, with escaping as necessary to make it a valid JSON string value.
       </para>
       <para>
        <literal>to_json('Fred said "Hi."'::text)</literal>
        <returnvalue>"Fred said \"Hi.\""</returnvalue>
       </para>
       <para>
        <literal>to_jsonb(row(42, 'Fred said "Hi."'::text))</literal>
        <returnvalue>{"f1": 42, "f2": "Fred said \"Hi.\""}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_json</primary>
        </indexterm>
        <function>array_to_json</function> ( <type>anyarray</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts a SQL array to a JSON array.  The behavior is the same
        as <function>to_json</function> except that line feeds will be added
        between top-level array elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>array_to_json('{{1,5},{99,100}}'::int[])</literal>
        <returnvalue>[[1,5],[99,100]]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_to_json</primary>
        </indexterm>
        <function>row_to_json</function> ( <type>record</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>json</returnvalue>
       </para>
       <para>
        Converts a SQL composite value to a JSON object.  The behavior is the
        same as <function>to_json</function> except that line feeds will be
        added between top-level elements if the optional boolean parameter is
        true.
       </para>
       <para>
        <literal>row_to_json(row(1,'foo'))</literal>
        <returnvalue>{"f1":1,"f2":"foo"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_array</primary>
        </indexterm>
        <function>json_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_array</primary>
        </indexterm>
        <function>jsonb_build_array</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a possibly-heterogeneously-typed JSON array out of a variadic
        argument list.  Each argument is converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_array(1,2,'foo',4,5)</literal>
        <returnvalue>[1, 2, "foo", 4, 5]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_build_object</primary>
        </indexterm>
        <function>json_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_build_object</primary>
        </indexterm>
        <function>jsonb_build_object</function> ( <literal>VARIADIC</literal> <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a variadic argument list.  By convention,
        the argument list consists of alternating keys and values.  Key
        arguments are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
       </para>
       <para>
        <literal>json_build_object('foo',1,2,row(3,'bar'))</literal>
        <returnvalue>{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object</primary>
        </indexterm>
        <function>json_object</function> ( <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object</primary>
        </indexterm>
        <function>jsonb_object</function> ( <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Builds a JSON object out of a text array.  The array must have either
        exactly one dimension with an even number of members, in which case
        they are taken as alternating key/value pairs, or two dimensions
        such that each inner array has exactly two elements, which
        are taken as a key/value pair.  All values are converted to JSON
        strings.
       </para>
       <para>
        <literal>json_object('{a, 1, b, "def", c, 3.5}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para>
        <para><literal>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</literal>
        <returnvalue>{"a" : "1", "b" : "def", "c" : "3.5"}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>json_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <function>jsonb_object</function> ( <parameter>keys</parameter> <type>text[]</type>, <parameter>values</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        This form of <function>json_object</function> takes keys and values
        pairwise from separate text arrays.  Otherwise it is identical to
        the one-argument form.
       </para>
       <para>
        <literal>json_object('{a, b}', '{1,2}')</literal>
        <returnvalue>{"a": "1", "b": "2"}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
<xref linkend="functions-json-processing-table"/>に<type>json</type>と<type>jsonb</type>値を処理するのに使える関数を示します。
  </para>

  <table id="functions-json-processing-table">
    <title>JSON Processing Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements</primary>
        </indexterm>
        <function>json_array_elements</function> ( <type>json</type> )
        <returnvalue>setof json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements</primary>
        </indexterm>
        <function>jsonb_array_elements</function> ( <type>jsonb</type> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of JSON values.
       </para>
       <para>
        <literal>select * from json_array_elements('[1,true, [2,false]]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 1
 true
 [2,false]
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_elements_text</primary>
        </indexterm>
        <function>json_array_elements_text</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_elements_text</primary>
        </indexterm>
        <function>jsonb_array_elements_text</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array into a set of <type>text</type> values.
       </para>
       <para>
        <literal>select * from json_array_elements_text('["foo", "bar"]')</literal>
        <returnvalue></returnvalue>
<programlisting>
   value
-----------
 foo
 bar
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_array_length</primary>
        </indexterm>
        <function>json_array_length</function> ( <type>json</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_array_length</primary>
        </indexterm>
        <function>jsonb_array_length</function> ( <type>jsonb</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of elements in the top-level JSON array.
       </para>
       <para>
        <literal>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each</primary>
        </indexterm>
        <function>json_each</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>json</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each</primary>
        </indexterm>
        <function>jsonb_each</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>jsonb</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
       </para>
       <para>
        <literal>select * from json_each('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_each_text</primary>
        </indexterm>
        <function>json_each_text</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_each_text</primary>
        </indexterm>
        <function>jsonb_each_text</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
        ( <parameter>key</parameter> <type>text</type>,
        <parameter>value</parameter> <type>text</type> )
       </para>
       <para>
        Expands the top-level JSON object into a set of key/value pairs.
        The returned <parameter>value</parameter>s will be of
        type <type>text</type>.
       </para>
       <para>
        <literal>select * from json_each_text('{"a":"foo", "b":"bar"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 key | value
-----+-------
 a   | foo
 b   | bar
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path</primary>
        </indexterm>
        <function>json_extract_path</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path</primary>
        </indexterm>
        <function>jsonb_extract_path</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path.
        (This is functionally equivalent to the <literal>#&gt;</literal>
        operator, but writing the path out as a variadic list can be more
        convenient in some cases.)
       </para>
       <para>
        <literal>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_extract_path_text</primary>
        </indexterm>
        <function>json_extract_path_text</function> ( <parameter>from_json</parameter> <type>json</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_extract_path_text</primary>
        </indexterm>
        <function>jsonb_extract_path_text</function> ( <parameter>from_json</parameter> <type>jsonb</type>, <literal>VARIADIC</literal> <parameter>path_elems</parameter> <type>text[]</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Extracts JSON sub-object at the specified path as <type>text</type>.
        (This is functionally equivalent to the <literal>#&gt;&gt;</literal>
        operator.)
       </para>
       <para>
        <literal>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</literal>
        <returnvalue>foo</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_keys</primary>
        </indexterm>
        <function>json_object_keys</function> ( <type>json</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_keys</primary>
        </indexterm>
        <function>jsonb_object_keys</function> ( <type>jsonb</type> )
        <returnvalue>setof text</returnvalue>
       </para>
       <para>
        Returns the set of keys in the top-level JSON object.
       </para>
       <para>
        <literal>select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 json_object_keys
------------------
 f1
 f2
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_record</primary>
        </indexterm>
        <function>json_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_record</primary>
        </indexterm>
        <function>jsonb_populate_record</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        of the <parameter>base</parameter> argument.  The JSON object
        is scanned for fields whose names match column names of the output row
        type, and their values are inserted into those columns of the output.
        (Fields that do not correspond to any output column name are ignored.)
        In typical use, the value of <parameter>base</parameter> is just
        <literal>NULL</literal>, which means that any output columns that do
        not match any object field will be filled with nulls.  However,
        if <parameter>base</parameter> isn't <literal>NULL</literal> then
        the values it contains will be used for unmatched columns.
       </para>
       <para>
        To convert a JSON value to the SQL type of an output column, the
        following rules are applied in sequence:
        <itemizedlist spacing="compact">
         <listitem>
          <para>
           A JSON null value is converted to a SQL null in all cases.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is of type <type>json</type>
           or <type>jsonb</type>, the JSON value is just reproduced exactly.
          </para>
         </listitem>
         <listitem>
          <para>
           If the output column is a composite (row) type, and the JSON value
           is a JSON object, the fields of the object are converted to columns
           of the output row type by recursive application of these rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Likewise, if the output column is an array type and the JSON value
           is a JSON array, the elements of the JSON array are converted to
           elements of the output array by recursive application of these
           rules.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, if the JSON value is a string, the contents of the
           string are fed to the input conversion function for the column's
           data type.
          </para>
         </listitem>
         <listitem>
          <para>
           Otherwise, the ordinary text representation of the JSON value is
           fed to the input conversion function for the column's data type.
          </para>
         </listitem>
        </itemizedlist>
       </para>
       <para>
        While the example below uses a constant JSON value, typical use would
        be to reference a <type>json</type> or <type>jsonb</type> column
        laterally from another table in the query's <literal>FROM</literal>
        clause.  Writing <function>json_populate_record</function> in
        the <literal>FROM</literal> clause is good practice, since all of the
        extracted columns are available for use without duplicate function
        calls.
       </para>
       <para>
        <literal>create type subrowtype as (d int, e text);</literal>
        <literal>create type myrowtype as (a int, b text[], c subrowtype);</literal>
       </para>
       <para>
        <literal>select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_populate_recordset</primary>
        </indexterm>
        <function>json_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>json</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_populate_recordset</primary>
        </indexterm>
        <function>jsonb_populate_recordset</function> ( <parameter>base</parameter> <type>anyelement</type>, <parameter>from_json</parameter> <type>jsonb</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type of the <parameter>base</parameter> argument.
        Each element of the JSON array is processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>create type twoints as (a int, b int);</literal>
       </para>
       <para>
        <literal>select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2},{"a":3,"b":4}]')</literal>
        <returnvalue></returnvalue>
<programlisting>
 a | b
---+---
 1 | 2
 3 | 4
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_record</primary>
        </indexterm>
        <function>json_to_record</function> ( <type>json</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_record</primary>
        </indexterm>
        <function>jsonb_to_record</function> ( <type>jsonb</type> )
        <returnvalue>record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON object to a row having the composite type
        defined by an <literal>AS</literal> clause.  (As with all functions
        returning <type>record</type>, the calling query must explicitly
        define the structure of the record with an <literal>AS</literal>
        clause.)  The output record is filled from fields of the JSON object,
        in the same way as described above
        for <function>json[b]_populate_record</function>.  Since there is no
        input record value, unmatched columns are always filled with nulls.
       </para>
       <para>
        <literal>create type myrowtype as (a int, b text);</literal>
       </para>
       <para>
        <literal>select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_to_recordset</primary>
        </indexterm>
        <function>json_to_recordset</function> ( <type>json</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_to_recordset</primary>
        </indexterm>
        <function>jsonb_to_recordset</function> ( <type>jsonb</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Expands the top-level JSON array of objects to a set of rows having
        the composite type defined by an <literal>AS</literal> clause.  (As
        with all functions returning <type>record</type>, the calling query
        must explicitly define the structure of the record with
        an <literal>AS</literal> clause.)  Each element of the JSON array is
        processed as described above
        for <function>json[b]_populate_record</function>.
       </para>
       <para>
        <literal>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 |
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set</primary>
        </indexterm>
        <function>jsonb_set</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with the item designated by <parameter>path</parameter>
        replaced by <parameter>new_value</parameter>, or with
        <parameter>new_value</parameter> added if
        <parameter>create_if_missing</parameter> is true (which is the
        default) and the item designated by <parameter>path</parameter>
        does not exist.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range,
        and <parameter>create_if_missing</parameter> is true, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</literal>
        <returnvalue>[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</literal>
        <returnvalue>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_set_lax</primary>
        </indexterm>
        <function>jsonb_set_lax</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>create_if_missing</parameter> <type>boolean</type> <optional>, <parameter>null_value_treatment</parameter> <type>text</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        If <parameter>new_value</parameter> is not <literal>NULL</literal>,
        behaves identically to <literal>jsonb_set</literal>. Otherwise behaves
        according to the value
        of <parameter>null_value_treatment</parameter> which must be one
        of <literal>'raise_exception'</literal>,
        <literal>'use_json_null'</literal>, <literal>'delete_key'</literal>, or
        <literal>'return_target'</literal>. The default is
        <literal>'use_json_null'</literal>.
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</literal>
        <returnvalue>[{"f1":null,"f2":null},2,null,3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</literal>
        <returnvalue>[{"f1": 99, "f2": null}, 2]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_insert</primary>
        </indexterm>
        <function>jsonb_insert</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>text[]</type>, <parameter>new_value</parameter> <type>jsonb</type> <optional>, <parameter>insert_after</parameter> <type>boolean</type> </optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns <parameter>target</parameter>
        with <parameter>new_value</parameter> inserted.  If the item
        designated by the <parameter>path</parameter> is an array
        element, <parameter>new_value</parameter> will be inserted before
        that item if <parameter>insert_after</parameter> is false (which
        is the default), or after it
        if <parameter>insert_after</parameter> is true.  If the item
        designated by the <parameter>path</parameter> is an object
        field, <parameter>new_value</parameter> will be inserted only if
        the object does not already contain that key.
        All earlier steps in the path must exist, or
        the <parameter>target</parameter> is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the <parameter>path</parameter> count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</literal>
        <returnvalue>{"a": [0, "new_value", 1, 2]}</returnvalue>
       </para>
       <para>
        <literal>jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</literal>
        <returnvalue>{"a": [0, 1, "new_value", 2]}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_strip_nulls</primary>
        </indexterm>
        <function>json_strip_nulls</function> ( <type>json</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_strip_nulls</primary>
        </indexterm>
        <function>jsonb_strip_nulls</function> ( <type>jsonb</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Deletes all object fields that have null values from the given JSON
        value, recursively.  Null values that are not object fields are
        untouched.
       </para>
       <para>
        <literal>json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</literal>
        <returnvalue>[{"f1":1},2,null,3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists</primary>
        </indexterm>
        <function>jsonb_path_exists</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Checks whether the JSON path returns any item for the specified JSON
        value.
        If the <parameter>vars</parameter> argument is specified, it must
        be a JSON object, and its fields provide named values to be
        substituted into the <type>jsonpath</type> expression.
        If the <parameter>silent</parameter> argument is specified and
        is <literal>true</literal>, the function suppresses the same errors
        as the <literal>@?</literal> and <literal>@@</literal> operators do.
       </para>
       <para>
        <literal>jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match</primary>
        </indexterm>
        <function>jsonb_path_match</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns the result of a JSON path predicate check for the specified
        JSON value.  Only the first item of the result is taken into account.
        If the result is not Boolean, then <literal>NULL</literal> is returned.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max))', '{"min":2,"max":4}')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query</primary>
        </indexterm>
        <function>jsonb_path_query</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')</literal>
        <returnvalue></returnvalue>
<programlisting>
 jsonb_path_query
------------------
 2
 3
 4
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array</primary>
        </indexterm>
        <function>jsonb_path_query_array</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns all JSON items returned by the JSON path for the specified
        JSON value, as a JSON array.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first</primary>
        </indexterm>
        <function>jsonb_path_query_first</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Returns the first JSON item returned by the JSON path for the
        specified JSON value.  Returns <literal>NULL</literal> if there are no
        results.
        The optional <parameter>vars</parameter>
        and <parameter>silent</parameter> arguments act the same as
        for <function>jsonb_path_exists</function>.
       </para>
       <para>
        <literal>jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ >= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_path_exists_tz</primary>
        </indexterm>
        <function>jsonb_path_exists_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_match_tz</primary>
        </indexterm>
        <function>jsonb_path_match_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_tz</primary>
        </indexterm>
        <function>jsonb_path_query_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>setof jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_array_tz</primary>
        </indexterm>
        <function>jsonb_path_query_array_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_path_query_first_tz</primary>
        </indexterm>
        <function>jsonb_path_query_first_tz</function> ( <parameter>target</parameter> <type>jsonb</type>, <parameter>path</parameter> <type>jsonpath</type> <optional>, <parameter>vars</parameter> <type>jsonb</type> <optional>, <parameter>silent</parameter> <type>boolean</type> </optional></optional> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        These functions act like their counterparts described above without
        the <literal>_tz</literal> suffix, except that these functions support
        comparisons of date/time values that require timezone-aware
        conversions.  The example below requires interpretation of the
        date-only value <literal>2015-08-02</literal> as a timestamp with time
        zone, so the result depends on the current
        <xref linkend="guc-timezone"/> setting.  Due to this dependency, these
        functions are marked as stable, which means these functions cannot be
        used in indexes.  Their counterparts are immutable, and so can be used
        in indexes; but they will throw errors if asked to make such
        comparisons.
       </para>
       <para>
        <literal>jsonb_path_exists_tz('["2015-08-01 12:00:00 -05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>jsonb_pretty</primary>
        </indexterm>
        <function>jsonb_pretty</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts the given JSON value to pretty-printed, indented text.
       </para>
       <para>
        <literal>jsonb_pretty('[{"f1":1,"f2":null},2]')</literal>
        <returnvalue></returnvalue>
<programlisting>
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_typeof</primary>
        </indexterm>
        <function>json_typeof</function> ( <type>json</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_typeof</primary>
        </indexterm>
        <function>jsonb_typeof</function> ( <type>jsonb</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the type of the top-level JSON value as a text string.
        Possible types are
        <literal>object</literal>, <literal>array</literal>,
        <literal>string</literal>, <literal>number</literal>,
        <literal>boolean</literal>, and <literal>null</literal>.
        (The <literal>null</literal> result should not be confused
        with a SQL NULL; see the examples.)
       </para>
       <para>
        <literal>json_typeof('-123.4')</literal>
        <returnvalue>number</returnvalue>
       </para>
       <para>
        <literal>json_typeof('null'::json)</literal>
        <returnvalue>null</returnvalue>
       </para>
       <para>
        <literal>json_typeof(NULL::json) IS NULL</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
    See also <xref linkend="functions-aggregate"/> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object, and their <type>jsonb</type> equivalents,
    <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
  </para>
 </sect2>

 <sect2 id="functions-sqljson-path">
  <title>The SQL/JSON Path Language</title>

  <indexterm zone="functions-sqljson-path">
   <primary>SQL/JSON path language</primary>
  </indexterm>

  <para>
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
  </para>

  <para>
   JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding JSON item, or set of items, is returned.
   Path expressions are written in the SQL/JSON path language
   and can include arithmetic expressions and functions.
  </para>

  <para>
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is normally evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of JSON items is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
  </para>

  <para>
   To refer to the JSON value being queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> variable
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve sub-items
   of the context item. Each operator that follows deals with the
   result of the previous evaluation step.
  </para>

  <para>
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
<programlisting>
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</programlisting>
  </para>

  <para>
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator to descend through surrounding JSON objects:
<programlisting>
$.track.segments
</programlisting>
  </para>

  <para>
   To retrieve the contents of an array, you typically use the
   <literal>[*]</literal> operator. For example,
   the following path will return the location coordinates for all
   the available track segments:
<programlisting>
$.track.segments[*].location
</programlisting>
  </para>

  <para>
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Recall that JSON array indexes are 0-relative:
<programlisting>
$.track.segments[0].location
</programlisting>
  </para>

  <para>
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get the size of an array:
<programlisting>
$.track.segments.size()
</programlisting>
   More examples of using <type>jsonpath</type> operators
   and methods within path expressions appear below in
   <xref linkend="functions-sqljson-path-operators"/>.
  </para>

  <para>
   When defining a path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similarly to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:

<programlisting>
? (<replaceable>condition</replaceable>)
</programlisting>
  </para>

  <para>
   Filter expressions must be written just after the path evaluation step
   to which they should apply. The result of that step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which the filter expression
   returned <literal>true</literal>.
  </para>

  <para>
   The functions and operators that can be used in filter expressions are
   listed in <xref linkend="functions-sqljson-filter-ex-table"/>.  Within a
   filter expression, the <literal>@</literal> variable denotes the value
   being filtered (i.e., one result of the preceding path step).  You can
   write accessor operators after <literal>@</literal> to retrieve component
   items.
  </para>

  <para>
   For example, suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
<programlisting>
$.track.segments[*].HR ? (@ &gt; 130)
</programlisting>
  </para>

  <para>
   To get the start times of segments with such values, you have to
   filter out irrelevant segments before returning the start times, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
<programlisting>
$.track.segments[*] ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

  <para>
   You can use several filter expressions in sequence, if required. For
   example, the following expression selects start times of all segments that
   contain locations with relevant coordinates and high heart rate values:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"
</programlisting>
  </para>

  <para>
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
<programlisting>
$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)
</programlisting>
  </para>

  <para>
   You can also nest filter expressions within each other:
<programlisting>
$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()
</programlisting>
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
  </para>

  <para>
   <productname>PostgreSQL</productname>'s implementation of the SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
  </para>

  <itemizedlist>
   <listitem>
    <para>
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
<programlisting>
$.track.segments[*].HR &lt; 70
</programlisting>
    </para>
   </listitem>

   <listitem>
    <para>
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
    </para>
   </listitem>
  </itemizedlist>

   <sect3 id="strict-and-lax-modes">
   <title>Strict and Lax Modes</title>
    <para>
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
    </para>

   <itemizedlist>
    <listitem>
     <para>
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
     </para>
    </listitem>
    <listitem>
     <para>
      strict &mdash; if a structural error occurs, an error is raised.
     </para>
    </listitem>
   </itemizedlist>

   <para>
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
    <itemizedlist>
     <listitem>
      <para>
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
      </para>
     </listitem>
     <listitem>
      <para>
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
<programlisting>
lax $.track.segments.location
</programlisting>
   </para>

   <para>
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
<programlisting>
strict $.track.segments[*].location
</programlisting>
   </para>

   </sect3>

   <sect3 id="functions-sqljson-path-operators">
   <title>SQL/JSON Path Operators and Methods</title>

   <para>
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  Note that while the unary
    operators and methods can be applied to multiple values resulting from a
    preceding path step, the binary operators (addition etc.) can only be
    applied to single values.
   </para>

   <table id="functions-sqljson-op-table">
    <title><type>jsonpath</type> Operators and Methods</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator/Method
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Addition
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '$[0] + 3')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>+</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Unary plus (no operation); unlike addition, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</literal>
        <returnvalue>[2, 3, 4]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Subtraction
       </para>
       <para>
        <literal>jsonb_path_query('[2]', '7 - $[0]')</literal>
        <returnvalue>5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>-</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Negation; unlike subtraction, this can iterate over
        multiple values
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</literal>
        <returnvalue>[-2, -3, -4]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>*</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Multiplication
       </para>
       <para>
        <literal>jsonb_path_query('[4]', '2 * $[0]')</literal>
        <returnvalue>8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>/</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Division
       </para>
       <para>
        <literal>jsonb_path_query('[8.5]', '$[0] / 2')</literal>
        <returnvalue>4.2500000000000000</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>%</literal> <replaceable>number</replaceable>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Modulo (remainder)
       </para>
       <para>
        <literal>jsonb_path_query('[32]', '$[0] % 10')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>type()</literal>
        <returnvalue><replaceable>string</replaceable></returnvalue>
       </para>
       <para>
        Type of the JSON item (see <function>json_typeof</function>)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</literal>
        <returnvalue>["number", "string", "object"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>size()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Size of the JSON item (number of array elements, or 1 if not an
        array)
       </para>
       <para>
        <literal>jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>.</literal> <literal>double()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Approximate floating-point number converted from a JSON number or
        string
       </para>
       <para>
        <literal>jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</literal>
        <returnvalue>3.8</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>ceiling()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer greater than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>floor()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Nearest integer less than or equal to the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"h": 1.7}', '$.h.floor()')</literal>
        <returnvalue>1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>number</replaceable> <literal>.</literal> <literal>abs()</literal>
        <returnvalue><replaceable>number</replaceable></returnvalue>
       </para>
       <para>
        Absolute value of the given number
       </para>
       <para>
        <literal>jsonb_path_query('{"z": -0.3}', '$.z.abs()')</literal>
        <returnvalue>0.3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime()</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string
       </para>
       <para>
        <literal>jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</literal>
        <returnvalue>"2015-8-1"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>.</literal> <literal>datetime(<replaceable>template</replaceable>)</literal>
        <returnvalue><replaceable>datetime_type</replaceable></returnvalue>
        (see note)
       </para>
       <para>
        Date/time value converted from a string using the
        specified <function>to_timestamp</function> template
       </para>
       <para>
        <literal>jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</literal>
        <returnvalue>["12:30:00", "18:40:00"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>object</replaceable> <literal>.</literal> <literal>keyvalue()</literal>
        <returnvalue><replaceable>array</replaceable></returnvalue>
       </para>
       <para>
        The object's key-value pairs, represented as an array of objects
        containing three fields: <literal>"key"</literal>,
        <literal>"value"</literal>, and <literal>"id"</literal>;
        <literal>"id"</literal> is a unique identifier of the object the
        key-value pair belongs to
       </para>
       <para>
        <literal>jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</literal>
        <returnvalue>[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

    <note>
     <para>
      The result type of the <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal>
      methods can be <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, or <type>timestamp</type>.
      Both methods determine their result type dynamically.
     </para>
     <para>
      The <literal>datetime()</literal> method sequentially tries to
      match its input string to the ISO formats
      for <type>date</type>, <type>timetz</type>, <type>time</type>,
      <type>timestamptz</type>, and <type>timestamp</type>. It stops on
      the first matching format and emits the corresponding data type.
     </para>
     <para>
      The <literal>datetime(<replaceable>template</replaceable>)</literal>
      method determines the result type according to the fields used in the
      provided template string.
     </para>
     <para>
      The <literal>datetime()</literal> and
      <literal>datetime(<replaceable>template</replaceable>)</literal> methods
      use the same parsing rules as the <literal>to_timestamp</literal> SQL
      function does (see <xref linkend="functions-formatting"/>), with three
      exceptions.  First, these methods don't allow unmatched template
      patterns.  Second, only the following separators are allowed in the
      template string: minus sign, period, solidus (slash), comma, apostrophe,
      semicolon, colon and space.  Third, separators in the template string
      must exactly match the input string.
     </para>
     <para>
      If different date/time types need to be compared, an implicit cast is
      applied. A <type>date</type> value can be cast to <type>timestamp</type>
      or <type>timestamptz</type>, <type>timestamp</type> can be cast to
      <type>timestamptz</type>, and <type>time</type> to <type>timetz</type>.
      However, all but the first of these conversions depend on the current
      <xref linkend="guc-timezone"/> setting, and thus can only be performed
      within timezone-aware <type>jsonpath</type> functions.
     </para>
    </note>

   <para>
    <xref linkend="functions-sqljson-filter-ex-table"/> shows the available
    filter expression elements.
   </para>

   <table id="functions-sqljson-filter-ex-table">
    <title><type>jsonpath</type> Filter Expression Elements</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Predicate/Value
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>==</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Equality comparison (this, and the other comparison operators, work on
        all JSON scalar values)
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</literal>
        <returnvalue>[1, 1]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</literal>
        <returnvalue>["a"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>!=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Non-equality comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</literal>
        <returnvalue>["a", "c"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</literal>
        <returnvalue>[1]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&lt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Less-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</literal>
        <returnvalue>["a", "b"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</literal>
        <returnvalue>[3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>value</replaceable> <literal>&gt;=</literal> <replaceable>value</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Greater-than-or-equal-to comparison
       </para>
       <para>
        <literal>jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</literal>
        <returnvalue>[2, 3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>true</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>true</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</literal>
        <returnvalue>{"name": "Chris", "parent": true}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>false</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        JSON constant <literal>false</literal>
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</literal>
        <returnvalue>{"name": "John", "parent": false}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>null</literal>
        <returnvalue><replaceable>value</replaceable></returnvalue>
       </para>
       <para>
        JSON constant <literal>null</literal> (note that, unlike in SQL,
        comparison to <literal>null</literal> works normally)
       </para>
       <para>
        <literal>jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</literal>
        <returnvalue>"Mary"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>&amp;&amp;</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean AND
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>||</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean OR
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>!</literal> <replaceable>boolean</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Boolean NOT
       </para>
       <para>
        <literal>jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</literal>
        <returnvalue>7</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>boolean</replaceable> <literal>is unknown</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a Boolean condition is <literal>unknown</literal>.
       </para>
       <para>
        <literal>jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ > 0) is unknown)')</literal>
        <returnvalue>"foo"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>like_regex</literal> <replaceable>string</replaceable> <optional> <literal>flag</literal> <replaceable>string</replaceable> </optional>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the first operand matches the regular expression
        given by the second operand, optionally with modifications
        described by a string of <literal>flag</literal> characters (see
        <xref linkend="jsonpath-regular-expressions"/>).
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</literal>
        <returnvalue>["abc", "abdacb"]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</literal>
        <returnvalue>["abc", "aBdC", "abdacb"]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <replaceable>string</replaceable> <literal>starts with</literal> <replaceable>string</replaceable>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether the second operand is an initial substring of the first
        operand.
       </para>
       <para>
        <literal>jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</literal>
        <returnvalue>"John Smith"</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <literal>exists</literal> <literal>(</literal> <replaceable>path_expression</replaceable> <literal>)</literal>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Tests whether a path expression matches at least one SQL/JSON item.
        Returns <literal>unknown</literal> if the path expression would result
        in an error; the second example uses this to avoid a no-such-key error
        in strict mode.
       </para>
       <para>
        <literal>jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</literal>
        <returnvalue>[2, 4]</returnvalue>
       </para>
       <para>
        <literal>jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</literal>
        <returnvalue>[]</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   </sect3>

   <sect3 id="jsonpath-regular-expressions">
    <title>SQL/JSON Regular Expressions</title>

    <indexterm zone="jsonpath-regular-expressions">
     <primary><literal>LIKE_REGEX</literal></primary>
     <secondary>in SQL/JSON</secondary>
    </indexterm>

    <para>
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
<programlisting>
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</programlisting>
    </para>

    <para>
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
    </para>

    <para>
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
    </para>

    <para>
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match strings that contain only digits:
<programlisting>
$ ? (@ like_regex "^\\d+$")
</programlisting>
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="functions-sequence">
  <title>Sequence Manipulation Functions</title>

  <indexterm>
   <primary>sequence</primary>
  </indexterm>

  <para>
   This section describes functions for operating on <firstterm>sequence
   objects</firstterm>, also called sequence generators or just sequences.
   Sequence objects are special single-row tables created with <xref
   linkend="sql-createsequence"/>.
   Sequence objects are commonly used to generate unique identifiers
   for rows of a table.  The sequence functions, listed in <xref
   linkend="functions-sequence-table"/>, provide simple, multiuser-safe
   methods for obtaining successive sequence values from sequence
   objects.
  </para>

   <table id="functions-sequence-table">
    <title>Sequence Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nextval</primary>
        </indexterm>
        <function>nextval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Advances the sequence object to its next value and returns that value.
        This is done atomically: even if multiple sessions
        execute <function>nextval</function> concurrently, each will safely
        receive a distinct sequence value.
        If the sequence object has been created with default parameters,
        successive <function>nextval</function> calls will return successive
        values beginning with 1.  Other behaviors can be obtained by using
        appropriate parameters in the <xref linkend="sql-createsequence"/>
        command.
      </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>UPDATE</literal> privilege on the sequence.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>setval</primary>
        </indexterm>
        <function>setval</function> ( <type>regclass</type>, <type>bigint</type> <optional>, <type>boolean</type> </optional> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Sets the sequence object's current value, and optionally
        its <literal>is_called</literal> flag.  The two-parameter
        form sets the sequence's <literal>last_value</literal> field to the
        specified value and sets its <literal>is_called</literal> field to
        <literal>true</literal>, meaning that the next
        <function>nextval</function> will advance the sequence before
        returning a value.  The value that will be reported
        by <function>currval</function> is also set to the specified value.
        In the three-parameter form, <literal>is_called</literal> can be set
        to either <literal>true</literal>
        or <literal>false</literal>.  <literal>true</literal> has the same
        effect as the two-parameter form. If it is set
        to <literal>false</literal>, the next <function>nextval</function>
        will return exactly the specified value, and sequence advancement
        commences with the following <function>nextval</function>.
        Furthermore, the value reported by <function>currval</function> is not
        changed in this case.  For example,
<programlisting>
SELECT setval('myseq', 42);           <lineannotation>Next <function>nextval</function> will return 43</lineannotation>
SELECT setval('myseq', 42, true);     <lineannotation>Same as above</lineannotation>
SELECT setval('myseq', 42, false);    <lineannotation>Next <function>nextval</function> will return 42</lineannotation>
</programlisting>
        The result returned by <function>setval</function> is just the value of its
        second argument.
       </para>
       <para>
        This function requires <literal>UPDATE</literal> privilege on the
        sequence.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>currval</primary>
        </indexterm>
        <function>currval</function> ( <type>regclass</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently obtained
        by <function>nextval</function> for this sequence in the current
        session.  (An error is reported if <function>nextval</function> has
        never been called for this sequence in this session.)  Because this is
        returning a session-local value, it gives a predictable answer whether
        or not other sessions have executed <function>nextval</function> since
        the current session did.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the sequence.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lastval</primary>
        </indexterm>
        <function>lastval</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the value most recently returned by
        <function>nextval</function> in the current session. This function is
        identical to <function>currval</function>, except that instead
        of taking the sequence name as an argument it refers to whichever
        sequence <function>nextval</function> was most recently applied to
        in the current session. It is an error to call
        <function>lastval</function> if <function>nextval</function>
        has not yet been called in the current session.
       </para>
       <para>
        This function requires <literal>USAGE</literal>
        or <literal>SELECT</literal> privilege on the last used sequence.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <caution>
   <para>
    To avoid blocking concurrent transactions that obtain numbers from
    the same sequence, a <function>nextval</function> operation is never
    rolled back; that is, once a value has been fetched it is considered
    used and will not be returned again.  This is true even if the
    surrounding transaction later aborts, or if the calling query ends
    up not using the value.  For example an <command>INSERT</command> with
    an <literal>ON CONFLICT</literal> clause will compute the to-be-inserted
    tuple, including doing any required <function>nextval</function>
    calls, before detecting any conflict that would cause it to follow
    the <literal>ON CONFLICT</literal> rule instead.  Such cases will leave
    unused <quote>holes</quote> in the sequence of assigned values.
    Thus, <productname>PostgreSQL</productname> sequence
    objects <emphasis>cannot be used to obtain <quote>gapless</quote>
    sequences</emphasis>.
   </para>

   <para>
    Likewise, any sequence state changes made by <function>setval</function>
    are not undone if the transaction rolls back.
   </para>
  </caution>

  <para>
   The sequence to be operated on by a sequence function is specified by
   a <type>regclass</type> argument, which is simply the OID of the sequence in the
   <structname>pg_class</structname> system catalog.  You do not have to look up the
   OID by hand, however, since the <type>regclass</type> data type's input
   converter will do the work for you.  Just write the sequence name enclosed
   in single quotes so that it looks like a literal constant.  For
   compatibility with the handling of ordinary
   <acronym>SQL</acronym> names, the string will be converted to lower case
   unless it contains double quotes around the sequence name.  Thus:
<programlisting>
nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('"Foo"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
</programlisting>
   The sequence name can be schema-qualified if necessary:
<programlisting>
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
</programlisting>
   See <xref linkend="datatype-oid"/> for more information about
   <type>regclass</type>.
  </para>

  <note>
   <para>
    Before <productname>PostgreSQL</productname> 8.1, the arguments of the
    sequence functions were of type <type>text</type>, not <type>regclass</type>, and
    the above-described conversion from a text string to an OID value would
    happen at run time during each call.  For backward compatibility, this
    facility still exists, but internally it is now handled as an implicit
    coercion from <type>text</type> to <type>regclass</type> before the function is
    invoked.
   </para>

   <para>
    When you write the argument of a sequence function as an unadorned
    literal string, it becomes a constant of type <type>regclass</type>.
    Since this is really just an OID, it will track the originally
    identified sequence despite later renaming, schema reassignment,
    etc.  This <quote>early binding</quote> behavior is usually desirable for
    sequence references in column defaults and views.  But sometimes you might
    want <quote>late binding</quote> where the sequence reference is resolved
    at run time.  To get late-binding behavior, force the constant to be
    stored as a <type>text</type> constant instead of <type>regclass</type>:
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
    Note that late binding was the only behavior supported in
    <productname>PostgreSQL</productname> releases before 8.1, so you
    might need to do this to preserve the semantics of old applications.
   </para>

   <para>
    Of course, the argument of a sequence function can be an expression
    as well as a constant.  If it is a text expression then the implicit
    coercion will result in a run-time lookup.
   </para>
  </note>

 </sect1>


 <sect1 id="functions-conditional">
  <title>Conditional Expressions</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
   <primary>conditional expression</primary>
  </indexterm>

  <para>
   This section describes the <acronym>SQL</acronym>-compliant conditional expressions
   available in <productname>PostgreSQL</productname>.
  </para>

  <tip>
   <para>
    If your needs go beyond the capabilities of these conditional
    expressions, you might want to consider writing a server-side function
    in a more expressive programming language.
   </para>
  </tip>

   <note>
    <para>
     Although <token>COALESCE</token>, <token>GREATEST</token>, and
     <token>LEAST</token> are syntactically similar to functions, they are
     not ordinary functions, and thus cannot be used with explicit
     <token>VARIADIC</token> array arguments.
    </para>
   </note>

  <sect2 id="functions-case">
   <title><literal>CASE</literal></title>

  <para>
   The <acronym>SQL</acronym> <token>CASE</token> expression is a
   generic conditional expression, similar to if/else statements in
   other programming languages:

<synopsis>
CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   <token>CASE</token> clauses can be used wherever
   an expression is valid.  Each <replaceable>condition</replaceable> is an
   expression that returns a <type>boolean</type> result.  If the condition's
   result is true, the value of the <token>CASE</token> expression is the
   <replaceable>result</replaceable> that follows the condition, and the
   remainder of the <token>CASE</token> expression is not processed.  If the
   condition's result is not true, any subsequent <token>WHEN</token> clauses
   are examined in the same manner.  If no <token>WHEN</token>
   <replaceable>condition</replaceable> yields true, the value of the
   <token>CASE</token> expression is the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause.  If the <token>ELSE</token> clause is
   omitted and no condition is true, the result is null.
  </para>

   <para>
    An example:
<screen>
SELECT * FROM test;

 a
---
 1
 2
 3


SELECT a,
       CASE WHEN a=1 THEN 'one'
            WHEN a=2 THEN 'two'
            ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

  <para>
   The data types of all the <replaceable>result</replaceable>
   expressions must be convertible to a single output type.
   See <xref linkend="typeconv-union-case"/> for more details.
  </para>

  <para>
   There is a <quote>simple</quote> form of <token>CASE</token> expression
   that is a variant of the general form above:

<synopsis>
CASE <replaceable>expression</replaceable>
    WHEN <replaceable>value</replaceable> THEN <replaceable>result</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>result</replaceable></optional>
END
</synopsis>

   The first
   <replaceable>expression</replaceable> is computed, then compared to
   each of the <replaceable>value</replaceable> expressions in the
   <token>WHEN</token> clauses until one is found that is equal to it.  If
   no match is found, the <replaceable>result</replaceable> of the
   <token>ELSE</token> clause (or a null value) is returned.  This is similar
   to the <function>switch</function> statement in C.
  </para>

   <para>
    The example above can be written using the simple
    <token>CASE</token> syntax:
<screen>
SELECT a,
       CASE a WHEN 1 THEN 'one'
              WHEN 2 THEN 'two'
              ELSE 'other'
       END
    FROM test;

 a | case
---+-------
 1 | one
 2 | two
 3 | other
</screen>
   </para>

   <para>
    A <token>CASE</token> expression does not evaluate any subexpressions
    that are not needed to determine the result.  For example, this is a
    possible way of avoiding a division-by-zero failure:
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>

   <note>
    <para>
     As described in <xref linkend="syntax-express-eval"/>, there are various
     situations in which subexpressions of an expression are evaluated at
     different times, so that the principle that <quote><token>CASE</token>
     evaluates only necessary subexpressions</quote> is not ironclad.  For
     example a constant <literal>1/0</literal> subexpression will usually result in
     a division-by-zero failure at planning time, even if it's within
     a <token>CASE</token> arm that would never be entered at run time.
    </para>
   </note>
  </sect2>

  <sect2 id="functions-coalesce-nvl-ifnull">
   <title><literal>COALESCE</literal></title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

  <indexterm>
   <primary>NVL</primary>
  </indexterm>

  <indexterm>
   <primary>IFNULL</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
   The <function>COALESCE</function> function returns the first of its
   arguments that is not null.  Null is returned only if all arguments
   are null.  It is often used to substitute a default value for
   null values when data is retrieved for display, for example:
<programlisting>
SELECT COALESCE(description, short_description, '(none)') ...
</programlisting>
   This returns <varname>description</varname> if it is not null, otherwise
   <varname>short_description</varname> if it is not null, otherwise <literal>(none)</literal>.
  </para>

   <para>
    Like a <token>CASE</token> expression, <function>COALESCE</function> only
    evaluates the arguments that are needed to determine the result;
    that is, arguments to the right of the first non-null argument are
    not evaluated.  This SQL-standard function provides capabilities similar
    to <function>NVL</function> and <function>IFNULL</function>, which are used in some other
    database systems.
   </para>
  </sect2>

  <sect2 id="functions-nullif">
   <title><literal>NULLIF</literal></title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>value1</replaceable>, <replaceable>value2</replaceable>)
</synopsis>

  <para>
   The <function>NULLIF</function> function returns a null value if
   <replaceable>value1</replaceable> equals <replaceable>value2</replaceable>;
   otherwise it returns <replaceable>value1</replaceable>.
   This can be used to perform the inverse operation of the
   <function>COALESCE</function> example given above:
<programlisting>
SELECT NULLIF(value, '(none)') ...
</programlisting>
  </para>
  <para>
   In this example, if <literal>value</literal> is <literal>(none)</literal>,
   null is returned, otherwise the value of <literal>value</literal>
   is returned.
  </para>

  </sect2>

  <sect2 id="functions-greatest-least">
   <title><literal>GREATEST</literal> and <literal>LEAST</literal></title>

  <indexterm>
   <primary>GREATEST</primary>
  </indexterm>
  <indexterm>
   <primary>LEAST</primary>
  </indexterm>

<synopsis>
<function>GREATEST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>
<synopsis>
<function>LEAST</function>(<replaceable>value</replaceable> <optional>, ...</optional>)
</synopsis>

   <para>
    The <function>GREATEST</function> and <function>LEAST</function> functions select the
    largest or smallest value from a list of any number of expressions.
    The expressions must all be convertible to a common data type, which
    will be the type of the result
    (see <xref linkend="typeconv-union-case"/> for details).  NULL values
    in the list are ignored.  The result will be NULL only if all the
    expressions evaluate to NULL.
   </para>

   <para>
    Note that <function>GREATEST</function> and <function>LEAST</function> are not in
    the SQL standard, but are a common extension.  Some other databases
    make them return NULL if any argument is NULL, rather than only when
    all are NULL.
   </para>
  </sect2>
 </sect1>

 <sect1 id="functions-array">
  <title>Array Functions and Operators</title>

  <para>
   <xref linkend="array-operators-table"/> shows the specialized operators
   available for array types.
   In addition to those, the usual comparison operators shown in <xref
   linkend="functions-comparison-op-table"/> are available for
   arrays.  The comparison operators compare the array contents
   element-by-element, using the default B-tree comparison function for
   the element data type, and sort based on the first difference.
   In multidimensional arrays the elements are visited in row-major order
   (last subscript varies most rapidly).
   If the contents of two arrays are equal but the dimensionality is
   different, the first difference in the dimensionality information
   determines the sort order.  (This is a change from versions of
   <productname>PostgreSQL</productname> prior to 8.2: older versions would claim
   that two arrays with the same contents were equal, even if the
   number of dimensions or subscript ranges were different.)
  </para>

   <table id="array-operators-table">
    <title>Array Operators</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>@&gt;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first array contain the second, that is, does each element
        appearing in the second array equal some element of the first array?
        (Duplicates are not treated specially,
        thus <literal>ARRAY[1]</literal> and <literal>ARRAY[1,1]</literal> are
        each considered to contain the other.)
       </para>
       <para>
        <literal>ARRAY[1,4,3] @&gt; ARRAY[3,1,3]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first array contained by the second?
       </para>
       <para>
        <literal>ARRAY[2,2,7] &lt;@ ARRAY[1,7,4,2,6]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>&amp;&amp;</literal> <type>anyarray</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the arrays overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates the two arrays.  Concatenating a null or empty array is a
        no-op; otherwise the arrays must have the same number of dimensions
        (as illustrated by the first example) or differ in number of
        dimensions by one (as illustrated by the second).
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[4,5,6,7]</literal>
        <returnvalue>{1,2,3,4,5,6,7}</returnvalue>
       </para>
       <para>
        <literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal>
        <returnvalue>{{1,2,3},{4,5,6},{7,8,9}}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the front of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>3 || ARRAY[4,5,6]</literal>
        <returnvalue>{3,4,5,6}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates an element onto the end of an array (which must be
        empty or one-dimensional).
       </para>
       <para>
        <literal>ARRAY[4,5,6] || 7</literal>
        <returnvalue>{4,5,6,7}</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   See <xref linkend="arrays"/> for more details about array operator
   behavior.  See <xref linkend="indexes-types"/> for more details about
   which operators support indexed operations.
  </para>

  <para>
   <xref linkend="array-functions-table"/> shows the functions
   available for use with array types. See <xref linkend="arrays"/>
   for more information  and examples of the use of these functions.
  </para>

   <table id="array-functions-table">
    <title>Array Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_append</primary>
        </indexterm>
        <function>array_append</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Appends an element to the end of an array (same as
        the <type>anyarray</type> <literal>||</literal> <type>anyelement</type>
        operator).
       </para>
       <para>
        <literal>array_append(ARRAY[1,2], 3)</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_cat</primary>
        </indexterm>
        <function>array_cat</function> ( <type>anyarray</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates two arrays (same as
        the <type>anyarray</type> <literal>||</literal> <type>anyarray</type>
        operator).
       </para>
       <para>
        <literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal>
        <returnvalue>{1,2,3,4,5}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_dims</primary>
        </indexterm>
        <function>array_dims</function> ( <type>anyarray</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns a text representation of the array's dimensions.
       </para>
       <para>
        <literal>array_dims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>[1:2][1:3]</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_fill</primary>
        </indexterm>
        <function>array_fill</function> ( <type>anyelement</type>, <type>integer[]</type>
          <optional>, <type>integer[]</type> </optional> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Returns an array filled with copies of the given value, having
        dimensions of the lengths specified by the second argument.
        The optional third argument supplies lower-bound values for each
        dimension (which default to all <literal>1</literal>).
       </para>
       <para>
        <literal>array_fill(11, ARRAY[2,3])</literal>
        <returnvalue>{{11,11,11},{11,11,11}}</returnvalue>
       </para>
       <para>
        <literal>array_fill(7, ARRAY[3], ARRAY[2])</literal>
        <returnvalue>[2:4]={7,7,7}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_length</primary>
        </indexterm>
        <function>array_length</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the length of the requested array dimension.
       </para>
       <para>
        <literal>array_length(array[1,2,3], 1)</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_lower</primary>
        </indexterm>
        <function>array_lower</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the lower bound of the requested array dimension.
       </para>
       <para>
        <literal>array_lower('[0:2]={1,2,3}'::integer[], 1)</literal>
        <returnvalue>0</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_ndims</primary>
        </indexterm>
        <function>array_ndims</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the number of dimensions of the array.
       </para>
       <para>
        <literal>array_ndims(ARRAY[[1,2,3], [4,5,6]])</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_position</primary>
        </indexterm>
        <function>array_position</function> ( <type>anyarray</type>, <type>anyelement</type> <optional>, <type>integer</type> </optional> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the subscript of the first occurrence of the second argument
        in the array, or <literal>NULL</literal> if it's not present.
        If the third argument is given, the search begins at that subscript.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
       </para>
       <para>
        <literal>array_position(ARRAY['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'], 'mon')</literal>
        <returnvalue>2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_positions</primary>
        </indexterm>
        <function>array_positions</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>integer[]</returnvalue>
       </para>
       <para>
        Returns an array of the subscripts of all occurrences of the second
        argument in the array given as first argument.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to search for <literal>NULL</literal>.
        <literal>NULL</literal> is returned only if the array
        is <literal>NULL</literal>; if the value is not found in the array, an
        empty array is returned.
       </para>
       <para>
        <literal>array_positions(ARRAY['A','A','B','A'], 'A')</literal>
        <returnvalue>{1,2,4}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_prepend</primary>
        </indexterm>
        <function>array_prepend</function> ( <type>anyelement</type>, <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Prepends an element to the beginning of an array (same as
        the <type>anyelement</type> <literal>||</literal> <type>anyarray</type>
        operator).
       </para>
       <para>
        <literal>array_prepend(1, ARRAY[2,3])</literal>
        <returnvalue>{1,2,3}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_remove</primary>
        </indexterm>
        <function>array_remove</function> ( <type>anyarray</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Removes all elements equal to the given value from the array.
        The array must be one-dimensional.
        Comparisons are done using <literal>IS NOT DISTINCT FROM</literal>
        semantics, so it is possible to remove <literal>NULL</literal>s.
       </para>
       <para>
        <literal>array_remove(ARRAY[1,2,3,2], 2)</literal>
        <returnvalue>{1,3}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_replace</primary>
        </indexterm>
        <function>array_replace</function> ( <type>anyarray</type>, <type>anyelement</type>, <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Replaces each array element equal to the second argument with the
        third argument.
       </para>
       <para>
        <literal>array_replace(ARRAY[1,2,5,4], 5, 3)</literal>
        <returnvalue>{1,2,3,4}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_to_string</primary>
        </indexterm>
        <function>array_to_string</function> ( <parameter>array</parameter> <type>anyarray</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Converts each array element to its text representation, and
        concatenates those separated by
        the <parameter>delimiter</parameter> string.
        If <parameter>null_string</parameter> is given and is
        not <literal>NULL</literal>, then <literal>NULL</literal> array
        entries are represented by that string; otherwise, they are omitted.
       </para>
       <para>
        <literal>array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')</literal>
        <returnvalue>1,2,3,*,5</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_upper</primary>
        </indexterm>
        <function>array_upper</function> ( <type>anyarray</type>, <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the upper bound of the requested array dimension.
       </para>
       <para>
        <literal>array_upper(ARRAY[1,8,3,7], 1)</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cardinality</primary>
        </indexterm>
        <function>cardinality</function> ( <type>anyarray</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the total number of elements in the array, or 0 if the array
        is empty.
       </para>
       <para>
        <literal>cardinality(ARRAY[[1,2],[3,4]])</literal>
        <returnvalue>4</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_to_array</primary>
        </indexterm>
        <function>string_to_array</function> ( <parameter>string</parameter> <type>text</type>, <parameter>delimiter</parameter> <type>text</type> <optional>, <parameter>null_string</parameter> <type>text</type> </optional> )
        <returnvalue>text[]</returnvalue>
       </para>
       <para>
        Splits the <parameter>string</parameter> at occurrences
        of <parameter>delimiter</parameter> and forms the remaining data
        into a <type>text</type> array.
        If <parameter>delimiter</parameter> is <literal>NULL</literal>,
        each character in the <parameter>string</parameter> will become a
        separate element in the array.
        If <parameter>delimiter</parameter> is an empty string, then
        the <parameter>string</parameter> is treated as a single field.
        If <parameter>null_string</parameter> is supplied and is
        not <literal>NULL</literal>, fields matching that string are converted
        to <literal>NULL</literal> entries.
       </para>
       <para>
        <literal>string_to_array('xx~~yy~~zz', '~~', 'yy')</literal>
        <returnvalue>{xx,NULL,zz}</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>unnest</primary>
        </indexterm>
        <function>unnest</function> ( <type>anyarray</type> )
        <returnvalue>setof anyelement</returnvalue>
       </para>
       <para>
        Expands an array to a set of rows.
       </para>
       <para>
        <literal>unnest(ARRAY[1,2])</literal>
        <returnvalue></returnvalue>
<programlisting>
 1
 2
</programlisting>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>unnest</function> ( <type>anyarray</type>, <type>anyarray</type> <optional>, ... </optional> )
        <returnvalue>setof anyelement, anyelement [, ... ]</returnvalue>
       </para>
       <para>
        Expands multiple arrays (possibly of different data types) to a set of
        rows.  If the arrays are not all the same length then the shorter ones
        are padded with <literal>NULL</literal>s.  This is only allowed in a
        query's FROM clause; see <xref linkend="queries-tablefunctions"/>.
       </para>
       <para>
        <literal>select * from unnest(ARRAY[1,2], ARRAY['foo','bar','baz']) as x(a,b)</literal>
        <returnvalue></returnvalue>
<programlisting>
 a |  b
---+-----
 1 | foo
 2 | bar
   | baz
</programlisting>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     There are two differences in the behavior of <function>string_to_array</function>
     from pre-9.1 versions of <productname>PostgreSQL</productname>.
     First, it will return an empty (zero-element) array rather
     than <literal>NULL</literal> when the input string is of zero length.
     Second, if the delimiter string is <literal>NULL</literal>, the function
     splits the input into individual characters, rather than
     returning <literal>NULL</literal> as before.
    </para>
   </note>

   <para>
    See also <xref linkend="functions-aggregate"/> about the aggregate
    function <function>array_agg</function> for use with arrays.
   </para>
  </sect1>

 <sect1 id="functions-range">
  <title>Range Functions and Operators</title>

  <para>
   See <xref linkend="rangetypes"/> for an overview of range types.
  </para>

  <para>
   <xref linkend="range-operators-table"/> shows the specialized operators
   available for range types.
   In addition to those, the usual comparison operators shown in
   <xref linkend="functions-comparison-op-table"/> are available for range
   types.  The comparison operators order first by the range lower bounds, and
   only if those are equal do they compare the upper bounds.  This does not
   usually result in a useful overall ordering, but the operators are provided
   to allow unique indexes to be constructed on ranges.
  </para>

   <table id="range-operators-table">
    <title>Range Operators</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range contain the second?
       </para>
       <para>
        <literal>int4range(2,4) @&gt; int4range(2,3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>@&gt;</literal> <type>anyelement</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the range contain the element?
       </para>
       <para>
        <literal>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range contained by the second?
       </para>
       <para>
        <literal>int4range(2,4) &lt;@ int4range(1,7)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the element contained in the range?
       </para>
       <para>
        <literal>42 &lt;@ int4range(1,7)</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&amp;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Do the ranges overlap, that is, have any elements in common?
       </para>
       <para>
        <literal>int8range(3,7) &amp;&amp; int8range(4,12)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&lt;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range strictly left of the second?
       </para>
       <para>
        <literal>int8range(1,10) &lt;&lt; int8range(100,110)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&gt;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the first range strictly right of the second?
       </para>
       <para>
        <literal>int8range(50,60) &gt;&gt; int8range(20,30)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&lt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range not extend to the right of the second?
       </para>
       <para>
        <literal>int8range(1,20) &amp;&lt; int8range(18,20)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>&amp;&gt;</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does the first range not extend to the left of the second?
       </para>
       <para>
        <literal>int8range(7,20) &amp;&gt; int8range(5,10)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-|-</literal> <type>anyrange</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Are the ranges adjacent?
       </para>
       <para>
        <literal>numrange(1.1,2.2) -|- numrange(2.2,3.3)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>+</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the union of the ranges.  The ranges must overlap or be
        adjacent, so that the union is a single range (but
        see <function>range_merge()</function>).
       </para>
       <para>
        <literal>numrange(5,15) + numrange(10,20)</literal>
        <returnvalue>[5,20)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>*</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the intersection of the ranges.
       </para>
       <para>
        <literal>int8range(5,15) * int8range(10,20)</literal>
        <returnvalue>[10,15)</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>anyrange</type> <literal>-</literal> <type>anyrange</type>
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the difference of the ranges.  The second range must not be
        contained in the first in such a way that the difference would not be
        a single range.
       </para>
       <para>
        <literal>int8range(5,15) - int8range(10,20)</literal>
        <returnvalue>[5,10)</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   The left-of/right-of/adjacent operators always return false when an empty
   range is involved; that is, an empty range is not considered to be either
   before or after any other range.
  </para>

  <para>
   <xref linkend="range-functions-table"/> shows the functions
   available for use with range types.
  </para>

   <table id="range-functions-table">
    <title>Range Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower</primary>
        </indexterm>
        <function>lower</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the lower bound of the range (<literal>NULL</literal> if the
        range is empty or the lower bound is infinite).
       </para>
       <para>
        <literal>lower(numrange(1.1,2.2))</literal>
        <returnvalue>1.1</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper</primary>
        </indexterm>
        <function>upper</function> ( <type>anyrange</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Extracts the upper bound of the range (<literal>NULL</literal> if the
        range is empty or the upper bound is infinite).
       </para>
       <para>
        <literal>upper(numrange(1.1,2.2))</literal>
        <returnvalue>2.2</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>isempty</primary>
        </indexterm>
        <function>isempty</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range empty?
       </para>
       <para>
        <literal>isempty(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inc</primary>
        </indexterm>
        <function>lower_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's lower bound inclusive?
       </para>
       <para>
        <literal>lower_inc(numrange(1.1,2.2))</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inc</primary>
        </indexterm>
        <function>upper_inc</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's upper bound inclusive?
       </para>
       <para>
        <literal>upper_inc(numrange(1.1,2.2))</literal>
        <returnvalue>f</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lower_inf</primary>
        </indexterm>
        <function>lower_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's lower bound infinite?
       </para>
       <para>
        <literal>lower_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>upper_inf</primary>
        </indexterm>
        <function>upper_inf</function> ( <type>anyrange</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is the range's upper bound infinite?
       </para>
       <para>
        <literal>upper_inf('(,)'::daterange)</literal>
        <returnvalue>t</returnvalue>
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>range_merge</primary>
        </indexterm>
        <function>range_merge</function> ( <type>anyrange</type>, <type>anyrange</type> )
        <returnvalue>anyrange</returnvalue>
       </para>
       <para>
        Computes the smallest range that includes both of the given ranges.
       </para>
       <para>
        <literal>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</literal>
        <returnvalue>[1,4)</returnvalue>
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   The <function>lower_inc</function>, <function>upper_inc</function>,
   <function>lower_inf</function>, and <function>upper_inf</function>
   functions all return false for an empty range.
  </para>
  </sect1>

 <sect1 id="functions-aggregate">
  <title>Aggregate Functions</title>

  <indexterm zone="functions-aggregate">
<!--
   <primary>aggregate function</primary>
   <secondary>built-in</secondary>
-->
   <primary>順序集合集約</primary>
   <secondary>組み込み</secondary>
  </indexterm>

  <para>
   <firstterm>Aggregate functions</firstterm> compute a single result
   from a set of input values.  The built-in general-purpose aggregate
   functions are listed in <xref linkend="functions-aggregate-table"/>
   while statistical aggregates are in <xref
   linkend="functions-aggregate-statistics-table"/>.
   The built-in within-group ordered-set aggregate functions
   are listed in <xref linkend="functions-orderedset-table"/>
   while the built-in within-group hypothetical-set ones are in <xref
   linkend="functions-hypothetical-table"/>.  Grouping operations,
   which are closely related to aggregate functions, are listed in
   <xref linkend="functions-grouping-table"/>.
   The special syntax considerations for aggregate
   functions are explained in <xref linkend="syntax-aggregates"/>.
   Consult <xref linkend="tutorial-agg"/> for additional introductory
   information.
  </para>

  <para>
   Aggregate functions that support <firstterm>Partial Mode</firstterm>
   are eligible to participate in various optimizations, such as parallel
   aggregation.
  </para>

   <table id="functions-aggregate-table">
    <title>General-Purpose Aggregate Functions</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>array_agg</primary>
        </indexterm>
        <function>array_agg</function> ( <type>anynonarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Collects all the input values, including nulls, into an array.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>array_agg</function> ( <type>anyarray</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Concatenates all the input arrays into an array of one higher
        dimension.  (The inputs must all have the same dimensionality, and
        cannot be empty or null.)
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>average</primary>
        </indexterm>
        <indexterm>
         <primary>avg</primary>
        </indexterm>
        <function>avg</function> ( <type>smallint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>integer</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>real</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>avg</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        Computes the average (arithmetic mean) of all the non-null input
        values.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_and</primary>
        </indexterm>
        <function>bit_and</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_and</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise AND of all non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bit_or</primary>
        </indexterm>
        <function>bit_or</function> ( <type>smallint</type> )
        <returnvalue>smallint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bigint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>bit_or</function> ( <type>bit</type> )
        <returnvalue>bit</returnvalue>
       </para>
       <para>
        Computes the bitwise OR of all non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_and</primary>
        </indexterm>
        <function>bool_and</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if all non-null input values are true, otherwise false.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>bool_or</primary>
        </indexterm>
        <function>bool_or</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Returns true if any non-null input value is true, otherwise false.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>count</primary>
        </indexterm>
        <function>count</function> ( <literal>*</literal> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of input rows.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>count</function> ( <type>"any"</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of input rows in which the input value is not
        null.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>every</primary>
        </indexterm>
        <function>every</function> ( <type>boolean</type> )
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        This is the SQL standard's equivalent to <function>bool_and</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_agg</primary>
        </indexterm>
        <function>json_agg</function> ( <type>anyelement</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_agg</primary>
        </indexterm>
        <function>jsonb_agg</function> ( <type>anyelement</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Collects all the input values, including nulls, into a JSON array.
        Values are converted to JSON as per <function>to_json</function>
        or <function>to_jsonb</function>.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>json_object_agg</primary>
        </indexterm>
        <function>json_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>json</returnvalue>
       </para>
       <para role="func_signature">
        <indexterm>
         <primary>jsonb_object_agg</primary>
        </indexterm>
        <function>jsonb_object_agg</function> ( <parameter>key</parameter>
         <type>"any"</type>, <parameter>value</parameter>
         <type>"any"</type> )
        <returnvalue>jsonb</returnvalue>
       </para>
       <para>
        Collects all the key/value pairs into a JSON object.  Key arguments
        are coerced to text; value arguments are converted as
        per <function>to_json</function> or <function>to_jsonb</function>.
        Values can be null, but not keys.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>max</primary>
        </indexterm>
        <function>max</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        Computes the maximum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>,
        and arrays of any of these types.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>min</primary>
        </indexterm>
        <function>min</function> ( <replaceable>see text</replaceable> )
        <returnvalue><replaceable>same as input type</replaceable></returnvalue>
       </para>
       <para>
        Computes the minimum of the non-null input
        values.  Available for any numeric, string, date/time, or enum type,
        as well as <type>inet</type>, <type>interval</type>,
        <type>money</type>, <type>oid</type>, <type>pg_lsn</type>,
        <type>tid</type>,
        and arrays of any of these types.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>string_agg</primary>
        </indexterm>
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>text</type>, <parameter>delimiter</parameter> <type>text</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para role="func_signature">
        <function>string_agg</function> ( <parameter>value</parameter>
         <type>bytea</type>, <parameter>delimiter</parameter> <type>bytea</type> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Concatenates the non-null input values into a string.  Each value
        after the first is preceded by the
        corresponding <parameter>delimiter</parameter> (if it's not null).
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>sum</primary>
        </indexterm>
        <function>sum</function> ( <type>smallint</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>integer</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>bigint</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>numeric</type> )
        <returnvalue>numeric</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>real</type> )
        <returnvalue>real</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para role="func_signature">
        <function>sum</function> ( <type>money</type> )
        <returnvalue>money</returnvalue>
       </para>
       <para>
        Computes the sum of the non-null input values.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>xmlagg</primary>
        </indexterm>
        <function>xmlagg</function> ( <type>xml</type> )
        <returnvalue>xml</returnvalue>
       </para>
       <para>
        Concatenates the non-null XML input values (see
        <xref linkend="functions-xml-xmlagg"/>).
       </para></entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   It should be noted that except for <function>count</function>,
   these functions return a null value when no rows are selected.  In
   particular, <function>sum</function> of no rows returns null, not
   zero as one might expect, and <function>array_agg</function>
   returns null rather than an empty array when there are no input
   rows.  The <function>coalesce</function> function can be used to
   substitute zero or an empty array for null when necessary.
  </para>

  <para>
   The aggregate functions <function>array_agg</function>,
   <function>json_agg</function>, <function>jsonb_agg</function>,
   <function>json_object_agg</function>, <function>jsonb_object_agg</function>,
   <function>string_agg</function>,
   and <function>xmlagg</function>, as well as similar user-defined
   aggregate functions, produce meaningfully different result values
   depending on the order of the input values.  This ordering is
   unspecified by default, but can be controlled by writing an
   <literal>ORDER BY</literal> clause within the aggregate call, as shown in
   <xref linkend="syntax-aggregates"/>.
   Alternatively, supplying the input values from a sorted subquery
   will usually work.  For example:

<screen><![CDATA[
SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;
]]></screen>

   Beware that this approach can fail if the outer query level contains
   additional processing, such as a join, because that might cause the
   subquery's output to be reordered before the aggregate is computed.
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
      The boolean aggregates <function>bool_and</function> and
      <function>bool_or</function> correspond to the standard SQL aggregates
      <function>every</function> and <function>any</function> or
      <function>some</function>.
      <productname>PostgreSQL</productname>
      supports <function>every</function>, but not <function>any</function>
      or <function>some</function>, because there is an ambiguity built into
      the standard syntax:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      Here <function>ANY</function> can be considered either as introducing
      a subquery, or as being an aggregate function, if the subquery
      returns one row with a Boolean value.
      Thus the standard name cannot be given to these aggregates.
    </para>
  </note>

  <note>
   <para>
    Users accustomed to working with other SQL database management
    systems might be disappointed by the performance of the
    <function>count</function> aggregate when it is applied to the
    entire table. A query like:
<programlisting>
SELECT count(*) FROM sometable;
</programlisting>
    will require effort proportional to the size of the table:
    <productname>PostgreSQL</productname> will need to scan either the
    entire table or the entirety of an index that includes all rows in
    the table.
   </para>
  </note>

  <para>
   <xref linkend="functions-aggregate-statistics-table"/> shows
   aggregate functions typically used in statistical analysis.
   (These are separated out merely to avoid cluttering the listing
   of more-commonly-used aggregates.)  Functions shown as
   accepting <replaceable>numeric_type</replaceable> are available for all
   the types <type>smallint</type>, <type>integer</type>,
   <type>bigint</type>, <type>numeric</type>, <type>real</type>,
   and <type>double precision</type>.
   Where the description mentions
   <parameter>N</parameter>, it means the
   number of input rows for which all the input expressions are non-null.
   In all cases, null is returned if the computation is meaningless,
   for example when <parameter>N</parameter> is zero.
  </para>

  <indexterm>
   <primary>statistics</primary>
  </indexterm>
  <indexterm>
   <primary>linear regression</primary>
  </indexterm>

   <table id="functions-aggregate-statistics-table">
    <title>Aggregate Functions for Statistics</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>correlation</primary>
        </indexterm>
        <indexterm>
         <primary>corr</primary>
        </indexterm>
        <function>corr</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the correlation coefficient.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_pop</primary>
        </indexterm>
        <function>covar_pop</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the population covariance.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>covariance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>covar_samp</primary>
        </indexterm>
        <function>covar_samp</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the sample covariance.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgx</primary>
        </indexterm>
        <function>regr_avgx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the average of the independent variable,
        <literal>sum(<parameter>X</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_avgy</primary>
        </indexterm>
        <function>regr_avgy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the average of the dependent variable,
        <literal>sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_count</primary>
        </indexterm>
        <function>regr_count</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the number of rows in which both inputs are non-null.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression intercept</primary>
        </indexterm>
        <indexterm>
         <primary>regr_intercept</primary>
        </indexterm>
        <function>regr_intercept</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the y-intercept of the least-squares-fit linear equation
        determined by the
        (<parameter>X</parameter>, <parameter>Y</parameter>) pairs.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_r2</primary>
        </indexterm>
        <function>regr_r2</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the square of the correlation coefficient.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regression slope</primary>
        </indexterm>
        <indexterm>
         <primary>regr_slope</primary>
        </indexterm>
        <function>regr_slope</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the slope of the least-squares-fit linear equation determined
        by the (<parameter>X</parameter>, <parameter>Y</parameter>)
        pairs.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxx</primary>
        </indexterm>
        <function>regr_sxx</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of squares</quote> of the independent
        variable,
        <literal>sum(<parameter>X</parameter>^2) - sum(<parameter>X</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_sxy</primary>
        </indexterm>
        <function>regr_sxy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of products</quote> of independent times
        dependent variables,
        <literal>sum(<parameter>X</parameter>*<parameter>Y</parameter>) - sum(<parameter>X</parameter>) * sum(<parameter>Y</parameter>)/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>regr_syy</primary>
        </indexterm>
        <function>regr_syy</function> ( <parameter>Y</parameter> <type>double precision</type>, <parameter>X</parameter> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the <quote>sum of squares</quote> of the dependent
        variable,
        <literal>sum(<parameter>Y</parameter>^2) - sum(<parameter>Y</parameter>)^2/<parameter>N</parameter></literal>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
        </indexterm>
        <indexterm>
         <primary>stddev</primary>
        </indexterm>
        <function>stddev</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        This is a historical alias for <function>stddev_samp</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_pop</primary>
        </indexterm>
        <function>stddev_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the population standard deviation of the input values.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>standard deviation</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>stddev_samp</primary>
        </indexterm>
        <function>stddev_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the sample standard deviation of the input values.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
        </indexterm>
        <function>variance</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        This is a historical alias for <function>var_samp</function>.
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>population</secondary>
        </indexterm>
        <indexterm>
         <primary>var_pop</primary>
        </indexterm>
        <function>var_pop</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the population variance of the input values (square of the
        population standard deviation).
       </para></entry>
       <entry>Yes</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>variance</primary>
         <secondary>sample</secondary>
        </indexterm>
        <indexterm>
         <primary>var_samp</primary>
        </indexterm>
        <function>var_samp</function> ( <replaceable>numeric_type</replaceable> )
        <returnvalue></returnvalue> <type>double precision</type>
        for <type>real</type> or <type>double precision</type>,
        otherwise <type>numeric</type>
       </para>
       <para>
        Computes the sample variance of the input values (square of the sample
        standard deviation).
       </para></entry>
       <entry>Yes</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   <xref linkend="functions-orderedset-table"/> shows some
   aggregate functions that use the <firstterm>ordered-set aggregate</firstterm>
   syntax.  These functions are sometimes referred to as <quote>inverse
   distribution</quote> functions.  Their aggregated input is introduced by
   <literal>ORDER BY</literal>, and they may also take a <firstterm>direct
   argument</firstterm> that is not aggregated, but is computed only once.
   All these functions ignore null values in their aggregated input.
   For those that take a <parameter>fraction</parameter> parameter, the
   fraction value must be between 0 and 1; an error is thrown if not.
   However, a null <parameter>fraction</parameter> value simply produces a
   null result.
  </para>

  <indexterm>
   <primary>ordered-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>
  <indexterm>
   <primary>inverse distribution</primary>
  </indexterm>

   <table id="functions-orderedset-table">
    <title>Ordered-Set Aggregate Functions</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>mode</primary>
         <secondary>statistical</secondary>
        </indexterm>
        <function>mode</function> () <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Computes the <firstterm>mode</firstterm>, the most frequent
        value of the aggregated argument (arbitrarily choosing the first one
        if there are multiple equally-frequent values).  The aggregated
        argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>continuous</secondary>
        </indexterm>
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval</returnvalue>
       </para>
       <para>
        Computes the <firstterm>continuous percentile</firstterm>, a value
        corresponding to the specified <parameter>fraction</parameter>
        within the ordered set of aggregated argument values.  This will
        interpolate between adjacent input items if needed.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>double precision</type> )
        <returnvalue>double precision[]</returnvalue>
       </para>
       <para role="func_signature">
        <function>percentile_cont</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>interval</type> )
        <returnvalue>interval[]</returnvalue>
       </para>
       <para>
        Computes multiple continuous percentiles.  The result is an array of
        the same dimensions as the <parameter>fractions</parameter>
        parameter, with each non-null element replaced by the (possibly
        interpolated) value corresponding to that percentile.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percentile</primary>
         <secondary>discrete</secondary>
        </indexterm>
        <function>percentile_disc</function> ( <parameter>fraction</parameter> <type>double precision</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Computes the <firstterm>discrete percentile</firstterm>, the first
        value within the ordered set of aggregated argument values whose
        position in the ordering equals or exceeds the
        specified <parameter>fraction</parameter>.  The aggregated
        argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>percentile_disc</function> ( <parameter>fractions</parameter> <type>double precision[]</type> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <type>anyelement</type> )
        <returnvalue>anyarray</returnvalue>
       </para>
       <para>
        Computes multiple discrete percentiles.  The result is an array of the
        same dimensions as the <parameter>fractions</parameter> parameter,
        with each non-null element replaced by the input value corresponding
        to that percentile.
        The aggregated argument must be of a sortable type.
       </para></entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <indexterm>
   <primary>hypothetical-set aggregate</primary>
   <secondary>built-in</secondary>
  </indexterm>

  <para>
   Each of the <quote>hypothetical-set</quote> aggregates listed in
   <xref linkend="functions-hypothetical-table"/> is associated with a
   window function of the same name defined in
   <xref linkend="functions-window"/>.  In each case, the aggregate's result
   is the value that the associated window function would have
   returned for the <quote>hypothetical</quote> row constructed from
   <replaceable>args</replaceable>, if such a row had been added to the sorted
   group of rows represented by the <replaceable>sorted_args</replaceable>.
   For each of these functions, the list of direct arguments
   given in <replaceable>args</replaceable> must match the number and types of
   the aggregated arguments given in <replaceable>sorted_args</replaceable>.
   Unlike most built-in aggregates, these aggregates are not strict, that is
   they do not drop input rows containing nulls.  Null values sort according
   to the rule specified in the <literal>ORDER BY</literal> clause.
  </para>

   <table id="functions-hypothetical-table">
    <title>Hypothetical-Set Aggregate Functions</title>
    <tgroup cols="2">
     <colspec colname="col1" colwidth="10*"/>
     <colspec colname="col2" colwidth="1*"/>
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
       <entry>Partial Mode</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the rank of the hypothetical row, with gaps; that is, the row
        number of the first row in its peer group.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>dense_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Computes the rank of the hypothetical row, without gaps; this function
        effectively counts peer groups.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>percent_rank</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the relative rank of the hypothetical row, that is
        (<function>rank</function> - 1) / (total rows - 1).
        The value thus ranges from 0 to 1 inclusive.
       </para></entry>
       <entry>No</entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
         <secondary>hypothetical</secondary>
        </indexterm>
        <function>cume_dist</function> ( <replaceable>args</replaceable> ) <literal>WITHIN GROUP</literal> ( <literal>ORDER BY</literal> <replaceable>sorted_args</replaceable> )
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Computes the cumulative distribution, that is (number of rows
        preceding or peers with hypothetical row) / (total rows).  The value
        thus ranges from 1/<parameter>N</parameter> to 1.
       </para></entry>
       <entry>No</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <table id="functions-grouping-table">
   <title>Grouping Operations</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>GROUPING</primary>
        </indexterm>
        <function>GROUPING</function> ( <replaceable>group_by_expression(s)</replaceable> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns a bit mask indicating which <literal>GROUP BY</literal>
        expressions are not included in the current grouping set.
        Bits are assigned with the rightmost argument corresponding to the
        least-significant bit; each bit is 0 if the corresponding expression
        is included in the grouping criteria of the grouping set generating
        the current result row, and 1 if it is not included.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    The grouping operations shown in
    <xref linkend="functions-grouping-table"/> are used in conjunction with
    grouping sets (see <xref linkend="queries-grouping-sets"/>) to distinguish
    result rows.  The arguments to the <literal>GROUPING</literal> function
    are not actually evaluated, but they must exactly match expressions given
    in the <literal>GROUP BY</literal> clause of the associated query level.
    For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 make  | model | sales
-------+-------+-------
 Foo   | GT    |  10
 Foo   | Tour  |  20
 Bar   | City  |  15
 Bar   | Sport |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>
 make  | model | grouping | sum
-------+-------+----------+-----
 Foo   | GT    |        0 | 10
 Foo   | Tour  |        0 | 20
 Bar   | City  |        0 | 15
 Bar   | Sport |        0 | 5
 Foo   |       |        1 | 30
 Bar   |       |        1 | 20
       |       |        3 | 50
(7 rows)
</screen>
    Here, the <literal>grouping</literal> value <literal>0</literal> in the
    first four rows shows that those have been grouped normally, over both the
    grouping columns.  The value <literal>1</literal> indicates
    that <literal>model</literal> was not grouped by in the next-to-last two
    rows, and the value <literal>3</literal> indicates that
    neither <literal>make</literal> nor <literal>model</literal> was grouped
    by in the last row (which therefore is an aggregate over all the input
    rows).
   </para>

 </sect1>

 <sect1 id="functions-window">
  <title>Window Functions</title>

  <indexterm zone="functions-window">
   <primary>window function</primary>
   <secondary>built-in</secondary>
  </indexterm>

  <para>
   <firstterm>Window functions</firstterm> provide the ability to perform
   calculations across sets of rows that are related to the current query
   row.  See <xref linkend="tutorial-window"/> for an introduction to this
   feature, and <xref linkend="syntax-window-functions"/> for syntax
   details.
  </para>

  <para>
   The built-in window functions are listed in
   <xref linkend="functions-window-table"/>.  Note that these functions
   <emphasis>must</emphasis> be invoked using window function syntax, i.e., an
   <literal>OVER</literal> clause is required.
  </para>

  <para>
   In addition to these functions, any built-in or user-defined
   ordinary aggregate (i.e., not ordered-set or hypothetical-set aggregates)
   can be used as a window function; see
   <xref linkend="functions-aggregate"/> for a list of the built-in aggregates.
   Aggregate functions act as window functions only when an <literal>OVER</literal>
   clause follows the call; otherwise they act as plain aggregates
   and return a single row for the entire set.
  </para>

   <table id="functions-window-table">
    <title>General-Purpose Window Functions</title>
    <tgroup cols="1">
     <thead>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>row_number</primary>
        </indexterm>
        <function>row_number</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the number of the current row within its partition, counting
        from 1.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>rank</primary>
        </indexterm>
        <function>rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the rank of the current row, with gaps; that is,
        the <function>row_number</function> of the first row in its peer
        group.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>dense_rank</primary>
        </indexterm>
        <function>dense_rank</function> ()
        <returnvalue>bigint</returnvalue>
       </para>
       <para>
        Returns the rank of the current row, without gaps; this function
        effectively counts peer groups.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>percent_rank</primary>
        </indexterm>
        <function>percent_rank</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the relative rank of the current row, that is
        (<function>rank</function> - 1) / (total partition rows - 1).
        The value thus ranges from 0 to 1 inclusive.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>cume_dist</primary>
        </indexterm>
        <function>cume_dist</function> ()
        <returnvalue>double precision</returnvalue>
       </para>
       <para>
        Returns the cumulative distribution, that is (number of partition rows
        preceding or peers with current row) / (total partition rows).
        The value thus ranges from 1/<parameter>N</parameter> to 1.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>ntile</primary>
        </indexterm>
        <function>ntile</function> ( <parameter>num_buckets</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns an integer ranging from 1 to the argument value, dividing the
        partition as equally as possible.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lag</primary>
        </indexterm>
        <function>lag</function> ( <parameter>value</parameter> <type>anyelement</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows before the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of the same type as
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lead</primary>
        </indexterm>
        <function>lead</function> ( <parameter>value</parameter> <type>anyelement</type>
          <optional>, <parameter>offset</parameter> <type>integer</type>
          <optional>, <parameter>default</parameter> <type>anyelement</type> </optional></optional> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated at
        the row that is <parameter>offset</parameter>
        rows after the current row within the partition; if there is no such
        row, instead returns <parameter>default</parameter>
        (which must be of the same type as
        <parameter>value</parameter>).
        Both <parameter>offset</parameter> and
        <parameter>default</parameter> are evaluated
        with respect to the current row.  If omitted,
        <parameter>offset</parameter> defaults to 1 and
        <parameter>default</parameter> to <literal>NULL</literal>.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>first_value</primary>
        </indexterm>
        <function>first_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the first row of the window frame.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>last_value</primary>
        </indexterm>
        <function>last_value</function> ( <parameter>value</parameter> <type>anyelement</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the last row of the window frame.
       </para></entry>
      </row>

      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>nth_value</primary>
        </indexterm>
        <function>nth_value</function> ( <parameter>value</parameter> <type>anyelement</type>, <parameter>n</parameter> <type>integer</type> )
        <returnvalue>anyelement</returnvalue>
       </para>
       <para>
        Returns <parameter>value</parameter> evaluated
        at the row that is the <parameter>n</parameter>'th
        row of the window frame (counting from 1);
        returns <literal>NULL</literal> if there is no such row.
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   All of the functions listed in
   <xref linkend="functions-window-table"/> depend on the sort ordering
   specified by the <literal>ORDER BY</literal> clause of the associated window
   definition.  Rows that are not distinct when considering only the
   <literal>ORDER BY</literal> columns are said to be <firstterm>peers</firstterm>.
   The four ranking functions (including <function>cume_dist</function>) are
   defined so that they give the same answer for all rows of a peer group.
  </para>

  <para>
   Note that <function>first_value</function>, <function>last_value</function>, and
   <function>nth_value</function> consider only the rows within the <quote>window
   frame</quote>, which by default contains the rows from the start of the
   partition through the last peer of the current row.  This is
   likely to give unhelpful results for <function>last_value</function> and
   sometimes also <function>nth_value</function>.  You can redefine the frame by
   adding a suitable frame specification (<literal>RANGE</literal>,
   <literal>ROWS</literal> or <literal>GROUPS</literal>) to
   the <literal>OVER</literal> clause.
   See <xref linkend="syntax-window-functions"/> for more information
   about frame specifications.
  </para>

  <para>
   When an aggregate function is used as a window function, it aggregates
   over the rows within the current row's window frame.
   An aggregate used with <literal>ORDER BY</literal> and the default window frame
   definition produces a <quote>running sum</quote> type of behavior, which may or
   may not be what's wanted.  To obtain
   aggregation over the whole partition, omit <literal>ORDER BY</literal> or use
   <literal>ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>.
   Other frame specifications can be used to obtain other effects.
  </para>

  <note>
   <para>
    The SQL standard defines a <literal>RESPECT NULLS</literal> or
    <literal>IGNORE NULLS</literal> option for <function>lead</function>, <function>lag</function>,
    <function>first_value</function>, <function>last_value</function>, and
    <function>nth_value</function>.  This is not implemented in
    <productname>PostgreSQL</productname>: the behavior is always the
    same as the standard's default, namely <literal>RESPECT NULLS</literal>.
    Likewise, the standard's <literal>FROM FIRST</literal> or <literal>FROM LAST</literal>
    option for <function>nth_value</function> is not implemented: only the
    default <literal>FROM FIRST</literal> behavior is supported.  (You can achieve
    the result of <literal>FROM LAST</literal> by reversing the <literal>ORDER BY</literal>
    ordering.)
   </para>
  </note>

 </sect1>

<!-- split-func3-end -->
